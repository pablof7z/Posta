This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Posta.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
Sources/
  Posta/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
      Contents.json
    Components/
      AnimatedBackgroundView.swift
      AnimationComponents.swift
      EventPreviewView.swift
      FullScreenImageView.swift
      LoadingDots.swift
      MessageCard.swift
      PostaLogoView.swift
      ProfileLoader.swift
      QRScannerView.swift
      RelayStatusViews.swift
      RichTextView.swift
      TabButton.swift
      URLPreviewView.swift
      ViewModifiers.swift
    DataSources/
      NostrDataSources.swift
    Helpers/
      AsyncContentView.swift
    Utils/
      HapticFeedback.swift
    AboutView.swift
    AccountSettingsView.swift
    AdvancedSettingsView.swift
    AppearanceSettingsView.swift
    ComposeView.swift
    ContentView.swift
    DesignSystem.swift
    HomeView.swift
    Info.plist
    LaunchScreen.storyboard
    NDKManager.swift
    NotificationSettingsView.swift
    PostaApp.swift
    PostaAuthView.swift
    PostaWelcomeView.swift
    PrivacySettingsView.swift
    ProfileView.swift
    RelayManager.swift
    RelaySettingsView.swift
    ReplyTracker.swift
    SettingsView.swift
    SplashView.swift
    ThemeManager.swift
    ThreadView.swift
    VisualEffectBlur.swift
build.sh
deploy.sh
project.yml
README.md
refresh-project.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Posta.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="Sources/Posta/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "20x20"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "40x40"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "76x76"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="Sources/Posta/Assets.xcassets/Contents.json">
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="Sources/Posta/Components/AnimatedBackgroundView.swift">
import SwiftUI
struct AnimatedBackgroundView: View {
    @State private var animate = false
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Base gradient
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color.purple.opacity(0.4),
                        Color.blue.opacity(0.3),
                        Color.indigo.opacity(0.4)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                // Animated circles
                ForEach(0..<3) { index in
                    Circle()
                        .fill(
                            RadialGradient(
                                gradient: Gradient(colors: [
                                    Color.purple.opacity(0.3),
                                    Color.purple.opacity(0.1)
                                ]),
                                center: .center,
                                startRadius: 50,
                                endRadius: 150
                            )
                        )
                        .frame(width: 300, height: 300)
                        .offset(
                            x: animate ? CGFloat.random(in: -100...100) : 0,
                            y: animate ? CGFloat.random(in: -100...100) : 0
                        )
                        .blur(radius: 20)
                        .opacity(animate ? 0.8 : 0.4)
                        .animation(
                            .easeInOut(duration: Double.random(in: 4...8))
                            .repeatForever(autoreverses: true)
                            .delay(Double(index) * 0.5),
                            value: animate
                        )
                }
            }
        }
        .ignoresSafeArea()
        .onAppear {
            animate = true
        }
    }
}
</file>

<file path="Sources/Posta/Components/AnimationComponents.swift">
import SwiftUI
// MARK: - Wave Shape Helper
// Wave shape for background animation
struct WaveShape: Shape {
    var phase: Double
    var animatableData: Double {
        get { phase }
        set { phase = newValue }
    }
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let width = rect.width
        let height = rect.height
        let midHeight = height * 0.5
        let wavelength = width / 3
        path.move(to: CGPoint(x: 0, y: midHeight))
        for x in stride(from: 0, through: width, by: 1) {
            let relativeX = x / wavelength
            let y = Foundation.sin(relativeX * .pi * 2 + phase) * 50 + midHeight
            path.addLine(to: CGPoint(x: x, y: y))
        }
        path.addLine(to: CGPoint(x: width, y: height))
        path.addLine(to: CGPoint(x: 0, y: height))
        path.closeSubpath()
        return path
    }
}
// MARK: - Glowing Button Style
struct GlowingButtonStyle: ButtonStyle {
    let backgroundColor: Color
    let foregroundColor: Color
    let glowColor: Color
    init(
        backgroundColor: Color = .purple,
        foregroundColor: Color = .white,
        glowColor: Color = .purple
    ) {
        self.backgroundColor = backgroundColor
        self.foregroundColor = foregroundColor
        self.glowColor = glowColor
    }
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .foregroundColor(foregroundColor)
            .padding(.horizontal, 24)
            .padding(.vertical, 16)
            .background(
                ZStack {
                    // Glow effect
                    RoundedRectangle(cornerRadius: 16)
                        .fill(glowColor)
                        .blur(radius: configuration.isPressed ? 5 : 10)
                        .opacity(configuration.isPressed ? 0.6 : 0.4)
                    // Main background
                    RoundedRectangle(cornerRadius: 16)
                        .fill(backgroundColor)
                }
            )
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                glowColor.opacity(0.6),
                                glowColor.opacity(0.2)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            )
            .scaleEffect(configuration.isPressed ? 0.95 : 1)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)
    }
}
// Legacy button styles removed - Use PostaPrimaryButtonStyle and PostaSecondaryButtonStyle from DesignSystem.swift instead
// MARK: - Bounce Animation Modifier
struct BounceModifier: ViewModifier {
    @State private var bounce = false
    let delay: Double
    func body(content: Content) -> some View {
        content
            .offset(y: bounce ? 0 : -10)
            .animation(
                .interpolatingSpring(stiffness: 300, damping: 10)
                    .delay(delay)
                    .repeatForever(autoreverses: true),
                value: bounce
            )
            .onAppear {
                bounce = true
            }
    }
}
extension View {
    func bouncing(delay: Double = 0) -> some View {
        modifier(BounceModifier(delay: delay))
    }
}
</file>

<file path="Sources/Posta/Components/EventPreviewView.swift">
import SwiftUI
import NDKSwift
/// View for displaying previews of Nostr events (nevent, note mentions)
struct EventPreviewView: View {
    let eventReference: EventReference
    @Environment(NDKManager.self) var ndkManager
    @State private var event: NDKEvent?
    @State private var isLoading = true
    @State private var loadError: Error?
    @State private var eventTask: Task<Void, Never>?
    enum EventReference: Hashable {
        case eventId(String)
        case note(String)
        case nevent(String)
    }
    var body: some View {
        Group {
            if let event = event {
                // Render based on event kind
                switch event.kind {
                case EventKind.textNote:
                    TextNotePreview(event: event)
                default:
                    UnknownEventPreview(event: event)
                }
            } else if isLoading {
                // Loading state
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading event...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color(.tertiarySystemFill))
                .cornerRadius(12)
            } else if loadError != nil {
                // Error state
                HStack {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                    Text("Could not load event")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color(.tertiarySystemFill))
                .cornerRadius(12)
            }
        }
        .onAppear {
            loadEvent()
        }
        .onDisappear {
            eventTask?.cancel()
        }
    }
    private func loadEvent() {
        guard let ndk = ndkManager.ndk else { return }
        eventTask = Task {
            do {
                let eventId: String
                switch eventReference {
                case .eventId(let id):
                    eventId = id
                case .note(let bech32):
                    eventId = try Bech32.eventId(from: bech32)
                case .nevent(let bech32):
                    // TODO: Decode nevent to get event ID and relay hints
                    // For now, just try to extract event ID
                    eventId = String(bech32.dropFirst(7).prefix(64)) // Rough extraction
                }
                // Create filter for this specific event
                let filter = NDKFilter(
                    ids: [eventId],
                    limit: 1
                )
                // Use observe with maxAge > 0 to fetch and close
                let dataSource = ndk.observe(filter: filter, maxAge: 300) // 5 min cache
                for await fetchedEvent in dataSource.events {
                    await MainActor.run {
                        self.event = fetchedEvent
                        self.isLoading = false
                    }
                    break // We only need the first event
                }
                // If no event found after EOSE
                await MainActor.run {
                    if self.event == nil {
                        self.isLoading = false
                    }
                }
            } catch {
                await MainActor.run {
                    self.loadError = error
                    self.isLoading = false
                }
            }
        }
    }
}
/// Preview for text notes (kind:1) - embedded tweet style
struct TextNotePreview: View {
    let event: NDKEvent
    @Environment(NDKManager.self) var ndkManager
    @State private var profile: NDKUserProfile?
    @State private var profileTask: Task<Void, Never>?
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Author info
            HStack(spacing: 8) {
                // Avatar
                if let avatarURL = profile?.picture, let url = URL(string: avatarURL) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    } placeholder: {
                        Circle()
                            .fill(Color(.tertiarySystemFill))
                    }
                    .frame(width: 32, height: 32)
                    .clipShape(Circle())
                } else {
                    Circle()
                        .fill(Color(.tertiarySystemFill))
                        .frame(width: 32, height: 32)
                        .overlay(
                            Text(String(profile?.name?.prefix(1) ?? "?").uppercased())
                                .font(.caption)
                                .foregroundColor(.secondary)
                        )
                }
                VStack(alignment: .leading, spacing: 0) {
                    Text(profile?.displayName ?? profile?.name ?? "Unknown")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    Text("@\(profile?.name ?? String(event.pubkey.prefix(8)))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                // Timestamp
                Text(event.createdAt.formatted)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            // Content
            RichTextInline(
                content: event.content,
                tags: event.tags,
                currentUser: nil
            )
            .font(.system(size: 14))
            .lineLimit(6)
            .foregroundColor(.primary)
            // Interaction hints
            HStack {
                Image(systemName: "bubble.left")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Image(systemName: "arrow.2.squarepath")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Image(systemName: "heart")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
            }
            .padding(.top, 4)
        }
        .padding(12)
        .background(Color(.secondarySystemFill))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color(.separator).opacity(0.3), lineWidth: 1)
        )
        .onAppear {
            loadProfile()
        }
        .onDisappear {
            profileTask?.cancel()
        }
    }
    private func loadProfile() {
        guard let ndk = ndkManager.ndk else { return }
        profileTask = Task {
            let profileStream = await ndk.profileManager.observe(for: event.pubkey, maxAge: TimeConstants.hour)
            for await profile in profileStream {
                if let profile = profile {
                    await MainActor.run {
                        self.profile = profile
                    }
                    break
                }
            }
        }
    }
}
/// Preview for unknown event kinds with alt tag support
struct UnknownEventPreview: View {
    let event: NDKEvent
    @State private var showFullContent = false
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header
            HStack {
                Image(systemName: "doc.text")
                    .font(.system(size: 20))
                    .foregroundColor(.secondary)
                VStack(alignment: .leading, spacing: 2) {
                    Text("Event")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    Text("Kind \(event.kind)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            // Content or alt tag
            if let altContent = event.tagValue("alt") {
                // Show alt tag content
                Text(altContent)
                    .font(.system(size: 14))
                    .lineLimit(showFullContent ? nil : 3)
                    .foregroundColor(.primary)
            } else {
                // Show preview prompt or content
                if showFullContent {
                    Text(event.content)
                        .font(.system(size: 14))
                        .lineLimit(10)
                        .foregroundColor(.primary)
                } else {
                    Text("This is a kind \(event.kind) event. Tap to preview the content.")
                        .font(.system(size: 14))
                        .foregroundColor(.secondary)
                        .italic()
                }
            }
        }
        .padding(12)
        .background(Color(.secondarySystemFill))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color(.separator).opacity(0.3), lineWidth: 1)
        )
        .contentShape(Rectangle())
        .onTapGesture {
            if event.tagValue("alt") == nil {
                withAnimation {
                    showFullContent.toggle()
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/Components/FullScreenImageView.swift">
import SwiftUI
struct FullScreenImageView: View {
    let url: URL
    @Binding var isPresented: Bool
    @State private var dragOffset: CGSize = .zero
    @State private var dragVelocity: CGSize = .zero
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0
    @State private var imageOffset: CGSize = .zero
    @State private var imageOpacity: Double = 0
    @State private var backgroundOpacity: Double = 0
    @GestureState private var magnifyBy = 1.0
    private let dismissThreshold: CGFloat = 100
    private let velocityThreshold: CGFloat = 500
    var body: some View {
        ZStack {
            // Background
            Color.black
                .opacity(backgroundOpacity)
                .ignoresSafeArea()
                .onTapGesture {
                    dismiss()
                }
            // Image
            AsyncImage(url: url) { phase in
                switch phase {
                case .success(let image):
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .scaleEffect(scale * magnifyBy)
                        .offset(x: imageOffset.width + dragOffset.width,
                                y: imageOffset.height + dragOffset.height)
                        .opacity(imageOpacity)
                        .gesture(dragGesture)
                        .gesture(magnificationGesture)
                        .gesture(doubleTapGesture)
                case .empty:
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.5)
                case .failure(_):
                    Image(systemName: "photo")
                        .font(.system(size: 60))
                        .foregroundColor(.gray)
                @unknown default:
                    EmptyView()
                }
            }
            // Close button
            VStack {
                HStack {
                    Spacer()
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title)
                            .foregroundStyle(.white.opacity(0.7), Color.black.opacity(0.3))
                    }
                    .padding()
                }
                Spacer()
            }
            .opacity(imageOpacity)
        }
        .statusBarHidden()
        .onAppear {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                imageOpacity = 1.0
                backgroundOpacity = 0.9
            }
        }
    }
    private func dismiss() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            imageOpacity = 0
            backgroundOpacity = 0
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            isPresented = false
        }
    }
    private var dragGesture: some Gesture {
        DragGesture()
            .onChanged { value in
                if scale == 1.0 {
                    // Only allow dragging when not zoomed
                    dragOffset = value.translation
                    // Calculate opacity based on drag distance
                    let distance = abs(value.translation.height)
                    let opacity = 1.0 - min(distance / 300, 0.5)
                    imageOpacity = Double(opacity)
                    backgroundOpacity = Double(opacity * 0.9)
                } else {
                    // When zoomed, pan the image
                    imageOffset = CGSize(
                        width: value.translation.width + imageOffset.width,
                        height: value.translation.height + imageOffset.height
                    )
                }
            }
            .onEnded { value in
                if scale == 1.0 {
                    let shouldDismiss = abs(value.translation.height) > dismissThreshold ||
                                       abs(value.predictedEndTranslation.height) > velocityThreshold
                    if shouldDismiss {
                        // Dismiss with animation
                        dismiss()
                    } else {
                        // Snap back
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            dragOffset = .zero
                            imageOpacity = 1.0
                            backgroundOpacity = 0.9
                        }
                    }
                }
            }
    }
    private var magnificationGesture: some Gesture {
        MagnificationGesture()
            .updating($magnifyBy) { currentState, gestureState, _ in
                gestureState = currentState
            }
            .onEnded { value in
                lastScale *= value
                scale = min(max(lastScale, 1.0), 4.0)
                lastScale = scale
                // Reset offset if scale is back to 1
                if scale == 1.0 {
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                        imageOffset = .zero
                    }
                }
            }
    }
    private var doubleTapGesture: some Gesture {
        TapGesture(count: 2)
            .onEnded {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                    if scale > 1.0 {
                        scale = 1.0
                        lastScale = 1.0
                        imageOffset = .zero
                    } else {
                        scale = 2.0
                        lastScale = 2.0
                    }
                }
            }
    }
}
// Preview provider
struct FullScreenImageView_Previews: PreviewProvider {
    static var previews: some View {
        FullScreenImageView(
            url: URL(string: "https://example.com/image.jpg")!,
            isPresented: .constant(true)
        )
    }
}
</file>

<file path="Sources/Posta/Components/LoadingDots.swift">
import SwiftUI
struct LoadingDots: View {
    let dotSize: CGFloat
    let color: Color
    @State private var animatingDots = [false, false, false]
    var body: some View {
        HStack(spacing: dotSize / 2) {
            ForEach(0..<3) { index in
                Circle()
                    .fill(color)
                    .frame(width: dotSize, height: dotSize)
                    .scaleEffect(animatingDots[index] ? 1.3 : 0.7)
                    .animation(
                        .easeInOut(duration: 0.6)
                        .repeatForever()
                        .delay(Double(index) * 0.2),
                        value: animatingDots[index]
                    )
            }
        }
        .onAppear {
            for i in 0..<3 {
                animatingDots[i] = true
            }
        }
    }
}
</file>

<file path="Sources/Posta/Components/MessageCard.swift">
import SwiftUI
// MARK: - Message Card Component
struct MessageCard: View {
    let isPressed: Bool
    let hasUnread: Bool
    var body: some View {
        RoundedRectangle(cornerRadius: 16)
            .fill(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(.systemBackground),
                        Color(.systemBackground).opacity(0.95)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.purple.opacity(hasUnread ? 0.3 : 0.1),
                                Color.purple.opacity(hasUnread ? 0.2 : 0.05)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            )
            .shadow(
                color: Color.purple.opacity(isPressed ? 0.15 : (hasUnread ? 0.1 : 0.05)),
                radius: isPressed ? 4 : 8,
                x: 0,
                y: isPressed ? 2 : 4
            )
    }
}
// MARK: - Floating Action Button
struct FloatingActionButton: View {
    let icon: String
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.purple,
                                Color.purple.opacity(0.8)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 56, height: 56)
                    .shadow(
                        color: Color.purple.opacity(0.3),
                        radius: isPressed ? 4 : 12,
                        x: 0,
                        y: isPressed ? 2 : 6
                    )
                Image(systemName: icon)
                    .font(.system(size: 22, weight: .medium))
                    .foregroundColor(.white)
            }
        }
        .scaleEffect(isPressed ? 0.9 : 1)
        .onLongPressGesture(
            minimumDuration: 0,
            maximumDistance: .infinity,
            pressing: { pressing in
                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                    isPressed = pressing
                }
            },
            perform: { }
        )
    }
}
// MARK: - Enhanced Avatar View
struct EnhancedAvatarView: View {
    let url: URL?
    let size: CGFloat
    let fallbackText: String
    let showOnlineIndicator: Bool
    @State private var imageLoadFailed = false
    var body: some View {
        ZStack(alignment: .bottomTrailing) {
            if let url = url, !imageLoadFailed {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: size, height: size)
                            .clipShape(Circle())
                    case .failure(_):
                        fallbackView
                            .onAppear { imageLoadFailed = true }
                    case .empty:
                        shimmeringPlaceholder
                    @unknown default:
                        fallbackView
                    }
                }
            } else {
                fallbackView
            }
            if showOnlineIndicator {
                Circle()
                    .fill(Color.green)
                    .frame(width: size * 0.25, height: size * 0.25)
                    .overlay(
                        Circle()
                            .stroke(Color(.systemBackground), lineWidth: 2)
                    )
            }
        }
    }
    private var fallbackView: some View {
        Circle()
            .fill(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color.purple.opacity(0.3),
                        Color.purple.opacity(0.1)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: size, height: size)
            .overlay(
                Text(fallbackText)
                    .font(.system(size: size * 0.4, weight: .medium))
                    .foregroundColor(.purple)
            )
    }
    private var shimmeringPlaceholder: some View {
        Circle()
            .fill(Color(.systemGray5))
            .frame(width: size, height: size)
            .postaShimmer()
    }
}
// MARK: - Message Status Indicator
struct MessageStatusIndicator: View {
    enum Status {
        case sent, delivered, read, failed
    }
    let status: Status
    var body: some View {
        HStack(spacing: 2) {
            switch status {
            case .sent:
                Image(systemName: "checkmark")
                    .font(.system(size: 10, weight: .medium))
                    .foregroundColor(.secondary)
            case .delivered:
                HStack(spacing: -4) {
                    Image(systemName: "checkmark")
                    Image(systemName: "checkmark")
                }
                .font(.system(size: 10, weight: .medium))
                .foregroundColor(.secondary)
            case .read:
                HStack(spacing: -4) {
                    Image(systemName: "checkmark")
                    Image(systemName: "checkmark")
                }
                .font(.system(size: 10, weight: .medium))
                .foregroundColor(.purple)
            case .failed:
                Image(systemName: "exclamationmark.circle.fill")
                    .font(.system(size: 10))
                    .foregroundColor(.red)
            }
        }
    }
}
// MARK: - Animated Header Background
struct AnimatedHeaderBackground: View {
    @State private var phase: CGFloat = 0
    var body: some View {
        Canvas { context, size in
            let gradient = Gradient(colors: [
                Color.purple.opacity(0.1),
                Color.purple.opacity(0.05),
                Color.clear
            ])
            // Draw animated gradient circles
            for i in 0..<3 {
                let offset = Double(i) * 120
                let x = size.width * 0.5 + Foundation.cos(phase + offset) * 30
                let y = size.height * 0.5 + Foundation.sin(phase + offset) * 20
                let circle = Circle()
                    .path(in: CGRect(
                        x: x - 60,
                        y: y - 60,
                        width: 120,
                        height: 120
                    ))
                context.fill(
                    circle,
                    with: .radialGradient(
                        gradient,
                        center: CGPoint(x: x, y: y),
                        startRadius: 0,
                        endRadius: 60
                    )
                )
            }
        }
        .blur(radius: 20)
        .onAppear {
            withAnimation(.linear(duration: 10).repeatForever(autoreverses: false)) {
                phase = .pi * 2
            }
        }
    }
}
</file>

<file path="Sources/Posta/Components/PostaLogoView.swift">
import SwiftUI
// Custom envelope shape for Posta logo
struct EnvelopeShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let width = rect.width
        let height = rect.height
        // Envelope body
        path.move(to: CGPoint(x: 0, y: height * 0.3))
        path.addLine(to: CGPoint(x: 0, y: height))
        path.addLine(to: CGPoint(x: width, y: height))
        path.addLine(to: CGPoint(x: width, y: height * 0.3))
        // Envelope flap
        path.addLine(to: CGPoint(x: width * 0.5, y: height * 0.6))
        path.addLine(to: CGPoint(x: 0, y: height * 0.3))
        // Letter lines inside
        path.move(to: CGPoint(x: width * 0.2, y: height * 0.45))
        path.addLine(to: CGPoint(x: width * 0.8, y: height * 0.45))
        path.move(to: CGPoint(x: width * 0.2, y: height * 0.6))
        path.addLine(to: CGPoint(x: width * 0.8, y: height * 0.6))
        path.move(to: CGPoint(x: width * 0.2, y: height * 0.75))
        path.addLine(to: CGPoint(x: width * 0.6, y: height * 0.75))
        return path
    }
}
struct PostaLogoView: View {
    let size: CGFloat
    let color: Color
    @State private var letterOffset: CGFloat = 0
    @State private var letterRotation: Double = 0
    @State private var envelopeScale: CGFloat = 1
    init(size: CGFloat = 100, color: Color = .white) {
        self.size = size
        self.color = color
    }
    var body: some View {
        ZStack {
            // Background circle with gradient
            Circle()
                .fill(
                    RadialGradient(
                        gradient: Gradient(colors: [
                            color.opacity(0.3),
                            color.opacity(0.1),
                            Color.clear
                        ]),
                        center: .center,
                        startRadius: 5,
                        endRadius: size * 0.6
                    )
                )
                .frame(width: size * 1.4, height: size * 1.4)
                .blur(radius: 10)
            // Main envelope container
            ZStack {
                // Envelope back
                RoundedRectangle(cornerRadius: size * 0.1)
                    .fill(color)
                    .frame(width: size, height: size * 0.7)
                    .offset(y: size * 0.15)
                    .scaleEffect(envelopeScale)
                // Envelope flap
                TriangleShape()
                    .fill(color.opacity(0.9))
                    .frame(width: size, height: size * 0.5)
                    .offset(y: -size * 0.1)
                    .scaleEffect(envelopeScale)
                // Letter inside with lightning bolt
                ZStack {
                    RoundedRectangle(cornerRadius: size * 0.05)
                        .fill(Color.white)
                        .frame(width: size * 0.7, height: size * 0.5)
                        .shadow(color: color.opacity(0.3), radius: 5, x: 0, y: 2)
                    // Lightning bolt on letter
                    Image(systemName: "bolt.fill")
                        .font(.system(size: size * 0.25, weight: .bold))
                        .foregroundColor(color)
                        .rotationEffect(.degrees(letterRotation))
                }
                .offset(y: letterOffset)
                .animation(
                    .spring(response: 0.8, dampingFraction: 0.6)
                        .repeatForever(autoreverses: true),
                    value: letterOffset
                )
            }
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
                letterOffset = -size * 0.1
                letterRotation = 5
                envelopeScale = 1.05
            }
        }
    }
}
// Triangle shape for envelope flap
struct TriangleShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.closeSubpath()
        return path
    }
}
// Animated envelope opening effect
struct AnimatedEnvelopeView: View {
    let size: CGFloat
    let color: Color
    @State private var isOpen = false
    @State private var letterScale: CGFloat = 0
    @State private var flapRotation: Double = 0
    var body: some View {
        ZStack {
            // Envelope body
            RoundedRectangle(cornerRadius: size * 0.1)
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            color,
                            color.opacity(0.8)
                        ]),
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .frame(width: size, height: size * 0.7)
                .offset(y: size * 0.15)
            // Envelope flap
            TriangleShape()
                .fill(color.opacity(0.9))
                .frame(width: size, height: size * 0.5)
                .offset(y: -size * 0.1)
                .rotation3DEffect(
                    .degrees(flapRotation),
                    axis: (x: 1.0, y: 0.0, z: 0.0),
                    anchor: .bottom,
                    anchorZ: 0,
                    perspective: 1.0
                )
            // Letter with content
            ZStack {
                RoundedRectangle(cornerRadius: size * 0.05)
                    .fill(Color.white)
                    .frame(width: size * 0.7, height: size * 0.8)
                    .shadow(color: color.opacity(0.3), radius: 10, x: 0, y: 5)
                VStack(spacing: size * 0.05) {
                    Image(systemName: "bolt.fill")
                        .font(.system(size: size * 0.3, weight: .bold))
                        .foregroundColor(color)
                    Text("POSTA")
                        .font(.system(size: size * 0.12, weight: .black, design: .rounded))
                        .foregroundColor(color)
                }
            }
            .scaleEffect(letterScale)
            .offset(y: isOpen ? -size * 0.3 : 0)
        }
        .onAppear {
            withAnimation(.spring(response: 1.2, dampingFraction: 0.7).delay(0.5)) {
                isOpen = true
                flapRotation = -120
                letterScale = 1
            }
        }
    }
}
#Preview {
    VStack(spacing: 40) {
        PostaLogoView(size: 120, color: .purple)
        AnimatedEnvelopeView(size: 120, color: .purple)
    }
    .padding()
    .background(Color.black)
}
</file>

<file path="Sources/Posta/Components/ProfileLoader.swift">
import SwiftUI
import NDKSwift
/// A view that loads and displays content based on a user profile
struct ProfileLoader<Content: View>: View {
    let pubkey: String
    let content: (NDKUserProfile?) -> Content
    @Environment(NDKManager.self) var ndkManager
    @State private var profile: NDKUserProfile?
    @State private var profileTask: Task<Void, Never>?
    var body: some View {
        content(profile)
            .onAppear {
                loadProfile()
            }
            .onDisappear {
                profileTask?.cancel()
            }
    }
    private func loadProfile() {
        guard let ndk = ndkManager.ndk else { return }
        profileTask = Task {
            let profileStream = await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour)
            for await profile in profileStream {
                if let profile = profile {
                    await MainActor.run {
                        self.profile = profile
                    }
                    break
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/Components/QRScannerView.swift">
import SwiftUI
import AVFoundation
struct QRScannerView: UIViewControllerRepresentable {
    let onScanned: (String) -> Void
    func makeUIViewController(context: Context) -> QRScannerViewController {
        let controller = QRScannerViewController()
        controller.onScanned = onScanned
        return controller
    }
    func updateUIViewController(_ uiViewController: QRScannerViewController, context: Context) {}
}
class QRScannerViewController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {
    var captureSession: AVCaptureSession!
    var previewLayer: AVCaptureVideoPreviewLayer!
    var onScanned: ((String) -> Void)?
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = UIColor.black
        captureSession = AVCaptureSession()
        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video) else { return }
        let videoInput: AVCaptureDeviceInput
        do {
            videoInput = try AVCaptureDeviceInput(device: videoCaptureDevice)
        } catch {
            return
        }
        if (captureSession.canAddInput(videoInput)) {
            captureSession.addInput(videoInput)
        } else {
            failed()
            return
        }
        let metadataOutput = AVCaptureMetadataOutput()
        if (captureSession.canAddOutput(metadataOutput)) {
            captureSession.addOutput(metadataOutput)
            metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)
            metadataOutput.metadataObjectTypes = [.qr]
        } else {
            failed()
            return
        }
        previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        previewLayer.frame = view.layer.bounds
        previewLayer.videoGravity = .resizeAspectFill
        view.layer.addSublayer(previewLayer)
        // Add scanning overlay
        addScanningOverlay()
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.captureSession.startRunning()
        }
    }
    func failed() {
        let ac = UIAlertController(title: "Scanning not supported", message: "Your device does not support scanning a code from an item. Please use a device with a camera.", preferredStyle: .alert)
        ac.addAction(UIAlertAction(title: "OK", style: .default))
        present(ac, animated: true)
        captureSession = nil
    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        if (captureSession?.isRunning == false) {
            DispatchQueue.global(qos: .background).async { [weak self] in
                self?.captureSession.startRunning()
            }
        }
    }
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        if (captureSession?.isRunning == true) {
            captureSession.stopRunning()
        }
    }
    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {
        captureSession.stopRunning()
        if let metadataObject = metadataObjects.first {
            guard let readableObject = metadataObject as? AVMetadataMachineReadableCodeObject else { return }
            guard let stringValue = readableObject.stringValue else { return }
            AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))
            onScanned?(stringValue)
            dismiss(animated: true)
        }
    }
    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .portrait
    }
    private func addScanningOverlay() {
        // Add semi-transparent overlay
        let overlayView = UIView(frame: view.bounds)
        overlayView.backgroundColor = UIColor.black.withAlphaComponent(0.5)
        view.addSubview(overlayView)
        // Create scanning area
        let scanSize: CGFloat = min(view.bounds.width, view.bounds.height) * 0.7
        let scanRect = CGRect(
            x: (view.bounds.width - scanSize) / 2,
            y: (view.bounds.height - scanSize) / 2,
            width: scanSize,
            height: scanSize
        )
        // Create path for overlay with hole
        let path = UIBezierPath(rect: view.bounds)
        let scanPath = UIBezierPath(roundedRect: scanRect, cornerRadius: 20)
        path.append(scanPath.reversing())
        let maskLayer = CAShapeLayer()
        maskLayer.path = path.cgPath
        overlayView.layer.mask = maskLayer
        // Add corner brackets
        let cornerLength: CGFloat = 30
        let cornerWidth: CGFloat = 4
        let cornerRadius: CGFloat = 2
        // Top-left corner
        addCornerBracket(
            to: view,
            at: CGPoint(x: scanRect.minX, y: scanRect.minY),
            orientation: .topLeft,
            length: cornerLength,
            width: cornerWidth,
            radius: cornerRadius
        )
        // Top-right corner
        addCornerBracket(
            to: view,
            at: CGPoint(x: scanRect.maxX, y: scanRect.minY),
            orientation: .topRight,
            length: cornerLength,
            width: cornerWidth,
            radius: cornerRadius
        )
        // Bottom-left corner
        addCornerBracket(
            to: view,
            at: CGPoint(x: scanRect.minX, y: scanRect.maxY),
            orientation: .bottomLeft,
            length: cornerLength,
            width: cornerWidth,
            radius: cornerRadius
        )
        // Bottom-right corner
        addCornerBracket(
            to: view,
            at: CGPoint(x: scanRect.maxX, y: scanRect.maxY),
            orientation: .bottomRight,
            length: cornerLength,
            width: cornerWidth,
            radius: cornerRadius
        )
        // Add instruction label
        let label = UILabel()
        label.text = "Align QR code within frame"
        label.textColor = .white
        label.font = UIFont.systemFont(ofSize: 16, weight: .medium)
        label.textAlignment = .center
        label.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(label)
        NSLayoutConstraint.activate([
            label.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            label.topAnchor.constraint(equalTo: view.topAnchor, constant: scanRect.minY - 60)
        ])
        // Add close button
        let closeButton = UIButton(type: .system)
        closeButton.setImage(UIImage(systemName: "xmark.circle.fill"), for: .normal)
        closeButton.tintColor = .white
        closeButton.addTarget(self, action: #selector(closeTapped), for: .touchUpInside)
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(closeButton)
        NSLayoutConstraint.activate([
            closeButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),
            closeButton.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            closeButton.widthAnchor.constraint(equalToConstant: 44),
            closeButton.heightAnchor.constraint(equalToConstant: 44)
        ])
    }
    @objc private func closeTapped() {
        dismiss(animated: true)
    }
    enum CornerOrientation {
        case topLeft, topRight, bottomLeft, bottomRight
    }
    private func addCornerBracket(to view: UIView, at point: CGPoint, orientation: CornerOrientation, length: CGFloat, width: CGFloat, radius: CGFloat) {
        let path = UIBezierPath()
        switch orientation {
        case .topLeft:
            path.move(to: CGPoint(x: point.x + length, y: point.y))
            path.addLine(to: CGPoint(x: point.x + radius, y: point.y))
            path.addArc(withCenter: CGPoint(x: point.x + radius, y: point.y + radius),
                       radius: radius,
                       startAngle: .pi * 1.5,
                       endAngle: .pi,
                       clockwise: false)
            path.addLine(to: CGPoint(x: point.x, y: point.y + length))
        case .topRight:
            path.move(to: CGPoint(x: point.x - length, y: point.y))
            path.addLine(to: CGPoint(x: point.x - radius, y: point.y))
            path.addArc(withCenter: CGPoint(x: point.x - radius, y: point.y + radius),
                       radius: radius,
                       startAngle: .pi * 1.5,
                       endAngle: 0,
                       clockwise: true)
            path.addLine(to: CGPoint(x: point.x, y: point.y + length))
        case .bottomLeft:
            path.move(to: CGPoint(x: point.x + length, y: point.y))
            path.addLine(to: CGPoint(x: point.x + radius, y: point.y))
            path.addArc(withCenter: CGPoint(x: point.x + radius, y: point.y - radius),
                       radius: radius,
                       startAngle: .pi * 0.5,
                       endAngle: .pi,
                       clockwise: true)
            path.addLine(to: CGPoint(x: point.x, y: point.y - length))
        case .bottomRight:
            path.move(to: CGPoint(x: point.x - length, y: point.y))
            path.addLine(to: CGPoint(x: point.x - radius, y: point.y))
            path.addArc(withCenter: CGPoint(x: point.x - radius, y: point.y - radius),
                       radius: radius,
                       startAngle: .pi * 0.5,
                       endAngle: 0,
                       clockwise: false)
            path.addLine(to: CGPoint(x: point.x, y: point.y - length))
        }
        let shapeLayer = CAShapeLayer()
        shapeLayer.path = path.cgPath
        shapeLayer.strokeColor = UIColor.white.cgColor
        shapeLayer.fillColor = UIColor.clear.cgColor
        shapeLayer.lineWidth = width
        shapeLayer.lineCap = .round
        view.layer.addSublayer(shapeLayer)
    }
}
</file>

<file path="Sources/Posta/Components/RelayStatusViews.swift">
import SwiftUI
import NDKSwift
// MARK: - Connection Status Badge
/// A reusable view that displays relay connection status with both visual indicator and text
public struct ConnectionStatusBadge: View {
    let state: NDKRelayConnectionState
    let style: BadgeStyle
    public enum BadgeStyle {
        case full        // Shows dot + text + background
        case compact     // Shows only dot
        case text        // Shows only text
    }
    public init(state: NDKRelayConnectionState, style: BadgeStyle = .full) {
        self.state = state
        self.style = style
    }
    public var body: some View {
        switch style {
        case .full:
            HStack(spacing: 4) {
                Circle()
                    .fill(statusColor)
                    .frame(width: 8, height: 8)
                Text(statusText)
                    .font(.caption)
                    .fontWeight(.medium)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 2)
            .background(statusColor.opacity(0.2))
            .cornerRadius(12)
        case .compact:
            Circle()
                .fill(statusColor)
                .frame(width: 6, height: 6)
        case .text:
            Text(statusText)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(statusColor)
        }
    }
    private var statusColor: Color {
        switch state {
        case .connected:
            return .green
        case .connecting:
            return .orange
        case .disconnected:
            return .gray
        case .disconnecting:
            return .orange
        case .failed:
            return .red
        }
    }
    private var statusText: String {
        switch state {
        case .connected:
            return "Connected"
        case .connecting:
            return "Connecting"
        case .disconnected:
            return "Disconnected"
        case .disconnecting:
            return "Disconnecting"
        case .failed:
            return "Failed"
        }
    }
}
// MARK: - Relay Row View
/// A row view for displaying relay information with connection status
public struct RelayRowView: View {
    let url: String
    let state: NDKRelayConnectionState
    let lastSeen: Date?
    public init(url: String, state: NDKRelayConnectionState, lastSeen: Date? = nil) {
        self.url = url
        self.state = state
        self.lastSeen = lastSeen
    }
    public var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(displayUrl)
                    .font(.system(.body, design: .monospaced))
                    .lineLimit(1)
                if let lastSeen = lastSeen {
                    Text("Last seen \(lastSeen, style: .relative)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            Spacer()
            ConnectionStatusBadge(state: state, style: .full)
        }
        .padding(.vertical, 4)
    }
    private var displayUrl: String {
        url.replacingOccurrences(of: "wss://", with: "")
            .replacingOccurrences(of: "ws://", with: "")
            .trimmingCharacters(in: CharacterSet(charactersIn: "/"))
    }
}
// MARK: - Relay Stats View
/// A view that displays relay statistics and health information
public struct RelayStatsView: View {
    let totalRelays: Int
    let connectedRelays: Int
    let pendingMessages: Int
    public init(totalRelays: Int, connectedRelays: Int, pendingMessages: Int = 0) {
        self.totalRelays = totalRelays
        self.connectedRelays = connectedRelays
        self.pendingMessages = pendingMessages
    }
    public var body: some View {
        VStack(spacing: 16) {
            // Connection summary
            HStack(spacing: 24) {
                StatItem(
                    title: "Total",
                    value: "\(totalRelays)",
                    color: .primary
                )
                StatItem(
                    title: "Connected",
                    value: "\(connectedRelays)",
                    color: connectedRelays > 0 ? .green : .red
                )
                if pendingMessages > 0 {
                    StatItem(
                        title: "Pending",
                        value: "\(pendingMessages)",
                        color: .orange
                    )
                }
            }
            // Connection health indicator
            ConnectionHealthBar(
                connected: connectedRelays,
                total: totalRelays
            )
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(12)
    }
    struct StatItem: View {
        let title: String
        let value: String
        let color: Color
        var body: some View {
            VStack(spacing: 4) {
                Text(value)
                    .font(.title2)
                    .fontWeight(.semibold)
                    .foregroundColor(color)
                Text(title)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
    }
}
// MARK: - Connection Health Bar
/// A visual indicator of relay connection health
struct ConnectionHealthBar: View {
    let connected: Int
    let total: Int
    private var percentage: Double {
        guard total > 0 else { return 0 }
        return Double(connected) / Double(total)
    }
    private var healthColor: Color {
        switch percentage {
        case 0.8...1.0:
            return .green
        case 0.5..<0.8:
            return .orange
        default:
            return .red
        }
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text("Connection Health")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
                Text("\(Int(percentage * 100))%")
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(healthColor)
            }
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color(.systemGray5))
                        .frame(height: 8)
                    RoundedRectangle(cornerRadius: 4)
                        .fill(healthColor)
                        .frame(width: geometry.size.width * percentage, height: 8)
                        .animation(.easeInOut(duration: 0.3), value: percentage)
                }
            }
            .frame(height: 8)
        }
    }
}
</file>

<file path="Sources/Posta/Components/RichTextView.swift">
import SwiftUI
import NDKSwift
/// A view that renders parsed Nostr content with reactive profile loading and URL previews
struct RichTextView: View {
    let content: String
    let tags: [Tag]
    let currentUser: NDKUser?
    let showLinkPreviews: Bool
    @Environment(NDKManager.self) var ndkManager
    @State private var parsedContent: NDKParsedContent?
    @State private var profileCache: [String: NDKUserProfile] = [:]
    @State private var profileTasks: [String: Task<Void, Never>] = [:]
    @State private var trackedPubkeys: Set<String> = []
    init(content: String, tags: [Tag], currentUser: NDKUser? = nil, showLinkPreviews: Bool = true) {
        self.content = content
        self.tags = tags
        self.currentUser = currentUser
        self.showLinkPreviews = showLinkPreviews
    }
    var body: some View {
        Group {
            if let parsed = parsedContent {
                VStack(alignment: .leading, spacing: 8) {
                    renderComponents(parsed.components)
                        .onAppear {
                            loadProfilesForComponents(parsed.components)
                        }
                    // Show URL previews below the text
                    if showLinkPreviews {
                        ForEach(extractURLs(from: parsed.components), id: \.absoluteString) { url in
                            URLPreviewView(url: url)
                                .padding(.top, 4)
                        }
                        // Show event previews
                        ForEach(extractEventReferences(from: parsed.components), id: \.self) { reference in
                            EventPreviewView(eventReference: reference)
                                .padding(.top, 4)
                        }
                    }
                }
            } else {
                Text(content)
                    .task {
                        await parseContent()
                    }
            }
        }
        .onDisappear {
            // Cancel all profile loading tasks
            for task in profileTasks.values {
                task.cancel()
            }
        }
    }
    @ViewBuilder
    private func renderComponents(_ components: [NDKParsedContent.Component]) -> some View {
        // Combine adjacent text components for better text flow
        let mergedComponents = mergeTextComponents(components)
        // Create text with attributed components
        mergedComponents.reduce(Text("")) { result, component in
            result + renderComponent(component)
        }
    }
    private func mergeTextComponents(_ components: [NDKParsedContent.Component]) -> [NDKParsedContent.Component] {
        var merged: [NDKParsedContent.Component] = []
        var currentText = ""
        for component in components {
            switch component {
            case .text(let text):
                currentText += text
            default:
                if !currentText.isEmpty {
                    merged.append(.text(currentText))
                    currentText = ""
                }
                merged.append(component)
            }
        }
        if !currentText.isEmpty {
            merged.append(.text(currentText))
        }
        return merged
    }
    private func renderComponent(_ component: NDKParsedContent.Component) -> Text {
        switch component {
        case .text(let text):
            return Text(text)
        case .userMention(let pubkey, let npub):
            let displayName = profileCache[pubkey]?.displayName ?? profileCache[pubkey]?.name
            let text = displayName != nil ? "@\(displayName!)" : "@\(String(npub.prefix(16)))..."
            return Text(text)
                .foregroundColor(.accentColor)
        case .npubMention(let npub):
            // Try to get pubkey and load profile
            if let pubkey = try? String.fromNpub(npub) {
                let displayName = profileCache[pubkey]?.displayName ?? profileCache[pubkey]?.name
                let text = displayName != nil ? "@\(displayName!)" : "@\(String(npub.prefix(16)))..."
                return Text(text)
                    .foregroundColor(.accentColor)
            } else {
                return Text("@\(String(npub.prefix(16)))...")
                    .foregroundColor(.accentColor)
            }
        case .nprofileMention(let nprofile):
            // For now, just show truncated nprofile
            // TODO: Decode nprofile to get pubkey when NDK supports it
            return Text("@\(String(nprofile.prefix(16)))...")
                .foregroundColor(.accentColor)
        case .eventMention(let eventId):
            return Text(" \(String(eventId.prefix(8)))...")
                .foregroundColor(.accentColor)
                .underline()
        case .noteMention(let note):
            return Text(" \(String(note.prefix(16)))...")
                .foregroundColor(.accentColor)
                .underline()
        case .neventMention(let nevent):
            return Text(" \(String(nevent.prefix(16)))...")
                .foregroundColor(.accentColor)
                .underline()
        case .hashtag(let tag):
            return Text("#\(tag)")
                .foregroundColor(.accentColor)
        case .url(let url):
            // Don't render image URLs as text - they'll be shown as images below
            if isImageURL(url) {
                return Text("")
            } else {
                return Text(url.absoluteString)
                    .foregroundColor(.accentColor)
                    .underline()
            }
        }
    }
    private func parseContent() async {
        guard let ndk = ndkManager.ndk else { return }
        let parsed = await ndk.parseContent(content, tags: tags, currentUser: currentUser)
        await MainActor.run {
            self.parsedContent = parsed
        }
    }
    private func loadProfilesForComponents(_ components: [NDKParsedContent.Component]) {
        for component in components {
            switch component {
            case .userMention(let pubkey, _):
                loadProfile(for: pubkey)
            case .npubMention(let npub):
                if let pubkey = try? String.fromNpub(npub) {
                    loadProfile(for: pubkey)
                }
            default:
                break
            }
        }
    }
    private func loadProfile(for pubkey: String) {
        // Skip if already loading or loaded
        guard !trackedPubkeys.contains(pubkey),
              let ndk = ndkManager.ndk else { return }
        trackedPubkeys.insert(pubkey)
        let task = Task {
            let profileStream = await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour)
            for await profile in profileStream {
                if let profile = profile {
                    await MainActor.run {
                        self.profileCache[pubkey] = profile
                    }
                    break // We only need the first profile
                }
            }
        }
        profileTasks[pubkey] = task
    }
    private func extractURLs(from components: [NDKParsedContent.Component]) -> [URL] {
        var urls: [URL] = []
        for component in components {
            if case .url(let url) = component {
                urls.append(url)
            }
        }
        // Limit to first 3 URLs to avoid overwhelming the UI
        return Array(urls.prefix(3))
    }
    private func extractEventReferences(from components: [NDKParsedContent.Component]) -> [EventPreviewView.EventReference] {
        var references: [EventPreviewView.EventReference] = []
        for component in components {
            switch component {
            case .eventMention(let eventId):
                references.append(.eventId(eventId))
            case .noteMention(let note):
                references.append(.note(note))
            case .neventMention(let nevent):
                references.append(.nevent(nevent))
            default:
                break
            }
        }
        // Limit to first 2 event references
        return Array(references.prefix(2))
    }
    private func isImageURL(_ url: URL) -> Bool {
        let imageExtensions = ["jpg", "jpeg", "png", "gif", "webp", "heic", "svg", "bmp", "tiff"]
        let pathExtension = url.pathExtension.lowercased()
        if imageExtensions.contains(pathExtension) {
            return true
        }
        // Also check if URL contains image extension before query params
        let urlString = url.absoluteString.lowercased()
        for ext in imageExtensions {
            if urlString.contains(".\(ext)?") || urlString.contains(".\(ext)&") || urlString.contains(".\(ext)#") {
                return true
            }
        }
        return false
    }
}
/// A simpler text-only version for use in list views
struct RichTextInline: View {
    let content: String
    let tags: [Tag]
    let currentUser: NDKUser?
    @Environment(NDKManager.self) var ndkManager
    @State private var parsedContent: NDKParsedContent?
    @State private var profileCache: [String: NDKUserProfile] = [:]
    @State private var profileTasks: [String: Task<Void, Never>] = [:]
    @State private var trackedPubkeys: Set<String> = []
    var body: some View {
        Group {
            if let parsed = parsedContent {
                renderComponents(parsed.components)
                    .onAppear {
                        loadProfilesForComponents(parsed.components)
                    }
            } else {
                Text(content)
                    .task {
                        await parseContent()
                    }
            }
        }
        .onDisappear {
            // Cancel all profile loading tasks
            for task in profileTasks.values {
                task.cancel()
            }
        }
    }
    @ViewBuilder
    private func renderComponents(_ components: [NDKParsedContent.Component]) -> some View {
        // Combine adjacent text components for better text flow
        let mergedComponents = mergeTextComponents(components)
        // Create text with attributed components
        mergedComponents.reduce(Text("")) { result, component in
            result + renderComponent(component)
        }
    }
    private func mergeTextComponents(_ components: [NDKParsedContent.Component]) -> [NDKParsedContent.Component] {
        var merged: [NDKParsedContent.Component] = []
        var currentText = ""
        for component in components {
            switch component {
            case .text(let text):
                currentText += text
            default:
                if !currentText.isEmpty {
                    merged.append(.text(currentText))
                    currentText = ""
                }
                merged.append(component)
            }
        }
        if !currentText.isEmpty {
            merged.append(.text(currentText))
        }
        return merged
    }
    private func renderComponent(_ component: NDKParsedContent.Component) -> Text {
        switch component {
        case .text(let text):
            return Text(text)
        case .userMention(let pubkey, let npub):
            let displayName = profileCache[pubkey]?.displayName ?? profileCache[pubkey]?.name
            let text = displayName != nil ? "@\(displayName!)" : "@\(String(npub.prefix(16)))..."
            return Text(text)
                .foregroundColor(.accentColor)
        case .npubMention(let npub):
            // Try to get pubkey and load profile
            if let pubkey = try? String.fromNpub(npub) {
                let displayName = profileCache[pubkey]?.displayName ?? profileCache[pubkey]?.name
                let text = displayName != nil ? "@\(displayName!)" : "@\(String(npub.prefix(16)))..."
                return Text(text)
                    .foregroundColor(.accentColor)
            } else {
                return Text("@\(String(npub.prefix(16)))...")
                    .foregroundColor(.accentColor)
            }
        case .nprofileMention(let nprofile):
            // For now, just show truncated nprofile
            return Text("@\(String(nprofile.prefix(16)))...")
                .foregroundColor(.accentColor)
        case .eventMention(let eventId):
            return Text(" \(String(eventId.prefix(8)))...")
                .foregroundColor(.accentColor)
                .underline()
        case .noteMention(let note):
            return Text(" \(String(note.prefix(16)))...")
                .foregroundColor(.accentColor)
                .underline()
        case .neventMention(let nevent):
            return Text(" \(String(nevent.prefix(16)))...")
                .foregroundColor(.accentColor)
                .underline()
        case .hashtag(let tag):
            return Text("#\(tag)")
                .foregroundColor(.accentColor)
        case .url(let url):
            return Text(url.absoluteString)
                .foregroundColor(.accentColor)
                .underline()
        }
    }
    private func parseContent() async {
        guard let ndk = ndkManager.ndk else { return }
        let parsed = await ndk.parseContent(content, tags: tags, currentUser: currentUser)
        await MainActor.run {
            self.parsedContent = parsed
        }
    }
    private func loadProfilesForComponents(_ components: [NDKParsedContent.Component]) {
        for component in components {
            switch component {
            case .userMention(let pubkey, _):
                loadProfile(for: pubkey)
            case .npubMention(let npub):
                if let pubkey = try? String.fromNpub(npub) {
                    loadProfile(for: pubkey)
                }
            default:
                break
            }
        }
    }
    private func loadProfile(for pubkey: String) {
        // Skip if already loading or loaded
        guard !trackedPubkeys.contains(pubkey),
              let ndk = ndkManager.ndk else { return }
        trackedPubkeys.insert(pubkey)
        let task = Task {
            let profileStream = await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour)
            for await profile in profileStream {
                if let profile = profile {
                    await MainActor.run {
                        self.profileCache[pubkey] = profile
                    }
                    break // We only need the first profile
                }
            }
        }
        profileTasks[pubkey] = task
    }
}
</file>

<file path="Sources/Posta/Components/TabButton.swift">
import SwiftUI
struct TabButton: View {
    let title: String
    let icon: String
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(isSelected ? .purple : .secondary)
                Text(title)
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(isSelected ? .purple : .secondary)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .background(
                ZStack {
                    if isSelected {
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.purple.opacity(0.1))
                    }
                }
            )
            .overlay(
                GeometryReader { geometry in
                    if isSelected {
                        VStack {
                            Spacer()
                            Rectangle()
                                .fill(Color.purple)
                                .frame(width: geometry.size.width * 0.6, height: 2)
                                .frame(maxWidth: .infinity)
                        }
                    }
                }
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
</file>

<file path="Sources/Posta/Components/URLPreviewView.swift">
import SwiftUI
import LinkPresentation
/// View for displaying URL previews with image embedding support
struct URLPreviewView: View {
    let url: URL
    @State private var linkMetadata: LPLinkMetadata?
    @State private var isLoading = true
    @State private var isImage = false
    @State private var imageLoadFailed = false
    @State private var showFullScreenImage = false
    var body: some View {
        Group {
            if isImage && !imageLoadFailed {
                // Direct image display
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .empty:
                        ProgressView()
                            .frame(maxHeight: 200)
                            .frame(maxWidth: .infinity)
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(maxWidth: .infinity)
                            .frame(maxHeight: 500)
                            .cornerRadius(16)
                            .shadow(color: Color.black.opacity(0.1), radius: 8, x: 0, y: 4)
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(Color(.separator).opacity(0.2), lineWidth: 0.5)
                            )
                            .padding(.vertical, 4)
                            .onTapGesture {
                                showFullScreenImage = true
                            }
                    case .failure(_):
                        // Fall back to link preview
                        EmptyView()
                            .onAppear {
                                imageLoadFailed = true
                            }
                    @unknown default:
                        EmptyView()
                    }
                }
            } else if let metadata = linkMetadata {
                // Rich link preview
                LinkPreviewCard(metadata: metadata, url: url)
            } else if isLoading {
                // Loading state
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading preview...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color(.tertiarySystemFill))
                .cornerRadius(12)
            }
        }
        .onAppear {
            checkIfImage()
            if !isImage {
                fetchLinkMetadata()
            }
        }
        .fullScreenCover(isPresented: $showFullScreenImage) {
            FullScreenImageView(
                url: url,
                isPresented: $showFullScreenImage
            )
            .edgesIgnoringSafeArea(.all)
        }
    }
    private func checkIfImage() {
        let imageExtensions = ["jpg", "jpeg", "png", "gif", "webp", "heic", "svg"]
        let pathExtension = url.pathExtension.lowercased()
        isImage = imageExtensions.contains(pathExtension)
        // Also check content type from URL if possible
        if !isImage {
            // Check if URL ends with image extension after query params
            let urlString = url.absoluteString.lowercased()
            for ext in imageExtensions {
                if urlString.contains(".\(ext)?") || urlString.contains(".\(ext)&") {
                    isImage = true
                    break
                }
            }
        }
    }
    private func fetchLinkMetadata() {
        Task {
            let provider = LPMetadataProvider()
            provider.timeout = 5 // 5 second timeout
            do {
                let metadata = try await provider.startFetchingMetadata(for: url)
                await MainActor.run {
                    self.linkMetadata = metadata
                    self.isLoading = false
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                }
            }
        }
    }
}
/// Card view for displaying link metadata
struct LinkPreviewCard: View {
    let metadata: LPLinkMetadata
    let url: URL
    @State private var iconImage: UIImage?
    @State private var previewImage: UIImage?
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Preview image if available
            if let image = previewImage {
                Image(uiImage: image)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(maxHeight: 180)
                    .clipped()
                    .cornerRadius(8)
            }
            VStack(alignment: .leading, spacing: 4) {
                HStack(alignment: .top, spacing: 8) {
                    // Site icon
                    if let icon = iconImage {
                        Image(uiImage: icon)
                            .resizable()
                            .frame(width: 24, height: 24)
                            .cornerRadius(4)
                    }
                    VStack(alignment: .leading, spacing: 2) {
                        // Title
                        if let title = metadata.title {
                            Text(title)
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .lineLimit(2)
                                .foregroundColor(.primary)
                        }
                        // URL host
                        Text(url.host ?? url.absoluteString)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .lineLimit(1)
                    }
                    Spacer()
                }
                // Description if no preview image
                if previewImage == nil, let description = metadata.value(forKey: "_summary") as? String {
                    Text(description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(2)
                        .padding(.top, 2)
                }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
        }
        .background(Color(.secondarySystemFill))
        .cornerRadius(12)
        .onTapGesture {
            if UIApplication.shared.canOpenURL(url) {
                UIApplication.shared.open(url)
            }
        }
        .task {
            await loadImages()
        }
    }
    private func loadImages() async {
        // Load icon
        if let iconProvider = metadata.iconProvider {
            iconProvider.loadDataRepresentation(for: .image) { data, error in
                if let data = data, let image = UIImage(data: data) {
                    Task { @MainActor in
                        self.iconImage = image
                    }
                }
            }
        }
        // Load preview image
        if let imageProvider = metadata.imageProvider {
            imageProvider.loadDataRepresentation(for: .image) { data, error in
                if let data = data, let image = UIImage(data: data) {
                    Task { @MainActor in
                        self.previewImage = image
                    }
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/Components/ViewModifiers.swift">
import SwiftUI
// This file contains legacy view modifiers that are deprecated
// Please use the new design system in DesignSystem.swift instead
// MARK: - Legacy modifiers (to be removed)
// Keeping these temporarily for backward compatibility
// Will be removed once all views are updated
</file>

<file path="Sources/Posta/DataSources/NostrDataSources.swift">
import Foundation
import NDKSwift
import SwiftUI
import Combine
// MARK: - Errors
enum NostrError: LocalizedError {
    case signerRequired
    case invalidKey
    case networkError
    var errorDescription: String? {
        switch self {
        case .signerRequired:
            return "No signer available"
        case .invalidKey:
            return "Invalid private key"
        case .networkError:
            return "Network connection failed"
        }
    }
}
// MARK: - User Profile Data Source
/// Data source for user profile metadata
@MainActor
public class UserProfileDataSource: ObservableObject {
    @Published public private(set) var profile: NDKUserProfile?
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    private let ndk: NDK
    private let pubkey: String
    private var profileTask: Task<Void, Never>?
    public init(ndk: NDK, pubkey: String) {
        self.ndk = ndk
        self.pubkey = pubkey
        // Start observing immediately - no loading states
        profileTask = Task {
            await observeProfile()
        }
    }
    deinit {
        profileTask?.cancel()
    }
    private func observeProfile() async {
        // Use NDKProfileManager for best practices
        for await profileUpdate in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.profile = profileUpdate
                self.isLoading = false
            }
        }
    }
}
// MARK: - Multiple Profiles Data Source
/// Data source for multiple user profiles (e.g., for contact lists)
@MainActor
public class MultipleProfilesDataSource: ObservableObject {
    @Published public private(set) var profiles: [String: NDKUserProfile] = [:]
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    private let dataSource: NDKDataSource<NDKEvent>
    private let pubkeys: Set<String>
    public init(ndk: NDK, pubkeys: Set<String>) {
        self.pubkeys = pubkeys
        self.dataSource = ndk.observe(
            filter: NDKFilter(
                authors: Array(pubkeys),
                kinds: [0]
            ),
            maxAge: 0,  // Real-time updates
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observeProfiles()
        }
    }
    private func observeProfiles() async {
        dataSource.$data
            .map { events in
                var profileDict: [String: NDKUserProfile] = [:]
                // Group events by author
                let eventsByAuthor = Dictionary(grouping: events) { $0.pubkey }
                // Get the latest profile for each author
                for (pubkey, authorEvents) in eventsByAuthor {
                    if let latestEvent = authorEvents.sorted(by: { $0.createdAt > $1.createdAt }).first,
                       let profile = JSONCoding.safeDecode(NDKUserProfile.self, from: latestEvent.content.data(using: .utf8) ?? Data()) {
                        profileDict[pubkey] = profile
                    }
                }
                return profileDict
            }
            .assign(to: &$profiles)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
    public func profile(for pubkey: String) -> NDKUserProfile? {
        profiles[pubkey]
    }
}
// MARK: - Follow List Data Source
/// Data source for user's follow list (kind:3 events)
@MainActor
public class FollowListDataSource: ObservableObject {
    @Published public private(set) var followList: Set<String> = []
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    @Published public private(set) var lastUpdate: Date?
    private let dataSource: NDKDataSource<NDKEvent>
    public init(ndk: NDK, pubkey: String) {
        self.dataSource = ndk.observe(
            filter: NDKFilter(
                authors: [pubkey],
                kinds: [EventKind.contacts],
                limit: 1
            ),
            maxAge: 0,
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observeFollowList()
        }
    }
    private func observeFollowList() async {
        // Break complex expression into simpler parts
        let latestEventPublisher = dataSource.$data
            .map { events -> NDKEvent? in
                let sorted = events.sorted { $0.createdAt > $1.createdAt }
                return sorted.first
            }
            .compactMap { $0 }
        let followListPublisher = latestEventPublisher
            .map { event -> Set<String> in
                let pubkeys = event.tags
                    .filter { tag in
                        tag.count >= 2 && tag[0] == "p"
                    }
                    .map { tag in
                        tag[1]
                    }
                return Set(pubkeys)
            }
        followListPublisher.assign(to: &$followList)
        let timestampPublisher = latestEventPublisher
            .map { event -> Date? in
                Date(timeIntervalSince1970: TimeInterval(event.createdAt))
            }
        timestampPublisher.assign(to: &$lastUpdate)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
}
// MARK: - Notes Data Source
/// Data source for text notes (kind:1 events)
@MainActor
public class NotesDataSource: ObservableObject {
    @Published public private(set) var notes: [NDKEvent] = []
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    @Published public private(set) var hasEOSE = false
    private let dataSource: NDKDataSource<NDKEvent>
    private var eoseTask: Task<Void, Never>?
    public init(ndk: NDK, filter: NDKFilter) {
        self.dataSource = ndk.observe(
            filter: filter,
            maxAge: 0,
            cachePolicy: .cacheWithNetwork
        )
        Task {
            await observeNotes()
        }
    }
    deinit {
        eoseTask?.cancel()
    }
    private func observeNotes() async {
        // Monitor EOSE status
        eoseTask = Task {
            for await update in dataSource.relayUpdates {
                if case .eose = update {
                    hasEOSE = true
                }
            }
        }
        dataSource.$data
            .map { events in
                events.sorted { $0.createdAt > $1.createdAt }
            }
            .assign(to: &$notes)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
}
// MARK: - Session Notes Data Source
/// Data source for notes from followed users with session management
@MainActor
public class SessionNotesDataSource: ObservableObject {
    @Published public private(set) var notes: [NDKEvent] = []
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    @Published public private(set) var hasEOSE = false
    @Published public private(set) var sessionData: NDKSessionData?
    private var dataSource: NDKDataSource<NDKEvent>?
    private var eoseTask: Task<Void, Never>?
    private var signerMonitorTask: Task<Void, Never>?
    public let ndk: NDK
    public init(ndk: NDK) {
        self.ndk = ndk
        // Start monitoring for signer availability
        signerMonitorTask = Task {
            await monitorSignerAndSetup()
        }
    }
    /// Initialize with immediate setup if signer is available
    public static func createWithSetup(ndk: NDK) async -> SessionNotesDataSource {
        let dataSource = SessionNotesDataSource(ndk: ndk)
        await dataSource.setupSession()
        return dataSource
    }
    deinit {
        eoseTask?.cancel()
        signerMonitorTask?.cancel()
    }
    private func monitorSignerAndSetup() async {
        // If signer is already available, set up immediately
        if ndk.signer != nil {
            await setupSession()
            return
        }
        // Otherwise, monitor for signer availability
        // This is a placeholder - ideally NDK would provide a proper async stream for signer changes
        // For now, we'll check periodically but this should be improved in NDK
        while ndk.signer == nil {
            try? await Task.sleep(nanoseconds: 500_000_000) // 500ms
        }
        await setupSession()
    }
    private func setupSession() async {
        do {
            isLoading = true
            // Properly wait for signer without sleep loops
            guard let signer = ndk.signer else {
                // Don't treat missing signer as an error - just wait for it
                print(" [SessionNotesDataSource] Waiting for authentication...")
                isLoading = false
                return
            }
            // Start session with proper configuration
            let config = NDKSessionConfiguration(
                dataRequirements: [.followList, .muteList, .webOfTrust(depth: 2)],
                preloadStrategy: .progressive
            )
            let sessionData = try await ndk.startSession(signer: signer, config: config)
            self.sessionData = sessionData
            print(" [SessionNotesDataSource] Session started for pubkey: \(sessionData.pubkey)")
            print(" [SessionNotesDataSource] Follow list count: \(sessionData.followList.count)")
            print(" [SessionNotesDataSource] First 5 follows: \(Array(sessionData.followList.prefix(5)))")
            // Create reactive filter for notes from followed users
            _ = ReactiveFilter(
                dependencies: [.followList],
                builder: { sessionData in
                    let follows = Array(sessionData.followList)
                    return NDKFilter(
                        authors: follows + [sessionData.pubkey],
                        kinds: [1], // text notes
                        limit: 100
                    )
                }
            )
            // For now, observe with a static filter based on initial session data
            // TODO: Implement proper reactive filter support in NDK
            var authors = Array(sessionData.followList) + [sessionData.pubkey]
            // If user has no follows, add some popular accounts to bootstrap the feed
            if sessionData.followList.isEmpty {
                print(" [SessionNotesDataSource] User has no follows, adding popular accounts to bootstrap feed")
                // Add some popular Nostr accounts
                let popularAccounts = [
                    "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2", // jack
                    "3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d", // fiatjaf
                    "04c915daefee38317fa734444acee390a8269fe5810b2241e5e6dd343dfbecc9", // ODELL
                    "6e468422dfb74a5738702a8823b9b28168abab8655faacb6853cd0ee15deee93", // Gigi
                    "e88a691e98d9987c964521dff60025f60700378a4879180dcbbb4a5027850411" // nvk
                ]
                authors.append(contentsOf: popularAccounts)
            }
            print(" [SessionNotesDataSource] Creating filter for \(authors.count) authors")
            // Fetch notes from the last 24 hours to ensure we get some content
            let since = Timestamp(Date().timeIntervalSince1970 - 86400) // 24 hours ago
            let initialFilter = NDKFilter(
                authors: authors,
                kinds: [1], // text notes
                since: since,
                limit: 200
            )
            dataSource = ndk.observe(
                filter: initialFilter,
                maxAge: 0,
                cachePolicy: .cacheWithNetwork
            )
            print(" [SessionNotesDataSource] Started observing notes with filter")
            await observeNotes()
        } catch {
            self.error = error
            isLoading = false
        }
    }
    private func observeNotes() async {
        guard let dataSource = dataSource else { return }
        // Monitor EOSE status
        eoseTask = Task {
            for await update in dataSource.relayUpdates {
                switch update {
                case .eose(let relay):
                    hasEOSE = true
                    print(" [SessionNotesDataSource] EOSE received from relay: \(relay)")
                case .event(let event, let relay):
                    print(" [SessionNotesDataSource] Event received from \(relay): kind=\(event.kind), content=\(String(event.content.prefix(50)))...")
                case .closed(let relay):
                    print(" [SessionNotesDataSource] Subscription closed on relay: \(relay)")
                }
            }
        }
        dataSource.$data
            .map { events in
                print(" [SessionNotesDataSource] Received \(events.count) notes total")
                if events.isEmpty {
                    print(" [SessionNotesDataSource] No notes found - check if follow list is empty or relays are connected")
                }
                return events.sorted { $0.createdAt > $1.createdAt }
            }
            .assign(to: &$notes)
        dataSource.$isLoading.assign(to: &$isLoading)
        dataSource.$error.assign(to: &$error)
    }
    /// Refresh the feed by clearing and re-fetching
    public func refresh() async {
        notes.removeAll()
        hasEOSE = false
        // Force network fetch by recreating the data source
        if let sessionData = sessionData {
            let since = Timestamp(Date().timeIntervalSince1970 - 86400) // 24 hours ago
            let filter = NDKFilter(
                authors: Array(sessionData.followList) + [sessionData.pubkey],
                kinds: [1], // text notes
                since: since,
                limit: 200
            )
            dataSource = ndk.observe(
                filter: filter,
                maxAge: 0,
                cachePolicy: .networkOnly
            )
            await observeNotes()
        }
    }
}
</file>

<file path="Sources/Posta/Helpers/AsyncContentView.swift">
import SwiftUI
/// A view that loads content asynchronously and displays it when ready
struct AsyncContentView<Content: View, T>: View {
    let operation: () async -> T
    let content: (T) -> Content
    @State private var result: T?
    @State private var isLoading = true
    @State private var error: Error?
    var body: some View {
        Group {
            if isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity)
                    .padding()
            } else if let error = error {
                VStack(spacing: 12) {
                    Image(systemName: "exclamationmark.triangle")
                        .font(.largeTitle)
                        .foregroundStyle(.secondary)
                    Text("Error loading content")
                        .font(.headline)
                    Text(error.localizedDescription)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity)
                .padding()
            } else if let result = result {
                content(result)
            } else {
                Text("No data available")
                    .foregroundStyle(.secondary)
                    .frame(maxWidth: .infinity)
                    .padding()
            }
        }
        .task {
            isLoading = true
            error = nil
            do {
                try Task.checkCancellation() // Check if cancelled
                result = await operation()
            } catch {
                self.error = error
            }
            isLoading = false
        }
    }
}
/// A view that observes a data source and displays its content
struct DataSourceContentView<Content: View, DataSource: ObservableObject>: View where DataSource: AnyObject {
    @ObservedObject var dataSource: DataSource
    let loadingView: () -> AnyView
    let errorView: (Error) -> AnyView
    let content: () -> Content
    init(
        dataSource: DataSource,
        @ViewBuilder content: @escaping () -> Content,
        loadingView: @escaping () -> AnyView = { AnyView(ProgressView().frame(maxWidth: .infinity).padding()) },
        errorView: @escaping (Error) -> AnyView = { error in
            AnyView(
                VStack(spacing: 12) {
                    Image(systemName: "exclamationmark.triangle")
                        .font(.largeTitle)
                        .foregroundStyle(.secondary)
                    Text("Error")
                        .font(.headline)
                    Text(error.localizedDescription)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity)
                .padding()
            )
        }
    ) {
        self.dataSource = dataSource
        self.content = content
        self.loadingView = loadingView
        self.errorView = errorView
    }
    var body: some View {
        Group {
            // Check if dataSource has isLoading property
            if let mirror = Mirror(reflecting: dataSource).children.first(where: { $0.label == "isLoading" }),
               let isLoading = mirror.value as? Bool,
               isLoading {
                loadingView()
            }
            // Check if dataSource has error property
            else if let mirror = Mirror(reflecting: dataSource).children.first(where: { $0.label == "error" }),
                    let error = mirror.value as? Error {
                errorView(error)
            } else {
                content()
            }
        }
    }
}
</file>

<file path="Sources/Posta/Utils/HapticFeedback.swift">
import SwiftUI
import UIKit
// MARK: - Haptic Feedback Manager
enum HapticFeedback {
    // Impact styles
    enum ImpactStyle {
        case light
        case medium
        case heavy
        case soft
        case rigid
        var generator: UIImpactFeedbackGenerator {
            switch self {
            case .light:
                return UIImpactFeedbackGenerator(style: .light)
            case .medium:
                return UIImpactFeedbackGenerator(style: .medium)
            case .heavy:
                return UIImpactFeedbackGenerator(style: .heavy)
            case .soft:
                return UIImpactFeedbackGenerator(style: .soft)
            case .rigid:
                return UIImpactFeedbackGenerator(style: .rigid)
            }
        }
    }
    // Notification styles
    enum NotificationStyle {
        case success
        case warning
        case error
        var feedbackType: UINotificationFeedbackGenerator.FeedbackType {
            switch self {
            case .success:
                return .success
            case .warning:
                return .warning
            case .error:
                return .error
            }
        }
    }
    // Selection feedback
    static func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.prepare()
        generator.selectionChanged()
    }
    // Impact feedback
    static func impact(_ style: ImpactStyle) {
        let generator = style.generator
        generator.prepare()
        generator.impactOccurred()
    }
    // Notification feedback
    static func notification(_ style: NotificationStyle) {
        let generator = UINotificationFeedbackGenerator()
        generator.prepare()
        generator.notificationOccurred(style.feedbackType)
    }
    // Custom pattern feedback
    static func pattern(_ pattern: [TimeInterval], intensity: CGFloat = 1.0) {
        guard !pattern.isEmpty else { return }
        Task {
            for (index, delay) in pattern.enumerated() {
                if index > 0 {
                    try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                }
                impact(.light)
            }
        }
    }
}
// MARK: - View Extensions
extension View {
    /// Adds haptic feedback when the view is tapped
    func hapticTap(_ style: HapticFeedback.ImpactStyle = .light) -> some View {
        self.onTapGesture {
            HapticFeedback.impact(style)
        }
    }
    /// Adds haptic feedback when a boolean value changes
    func hapticChange<V: Equatable>(_ value: V, style: HapticFeedback.ImpactStyle = .light) -> some View {
        self.onChange(of: value) { _, _ in
            HapticFeedback.impact(style)
        }
    }
    /// Adds haptic feedback for button presses
    func hapticButton(_ style: HapticFeedback.ImpactStyle = .light) -> some View {
        self.simultaneousGesture(
            DragGesture(minimumDistance: 0)
                .onChanged { _ in
                    HapticFeedback.impact(style)
                }
        )
    }
}
// MARK: - Button Style with Haptics
struct HapticButtonStyle: ButtonStyle {
    let hapticStyle: HapticFeedback.ImpactStyle
    init(hapticStyle: HapticFeedback.ImpactStyle = .light) {
        self.hapticStyle = hapticStyle
    }
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1)
            .onChange(of: configuration.isPressed) { _, isPressed in
                if isPressed {
                    HapticFeedback.impact(hapticStyle)
                }
            }
    }
}
</file>

<file path="Sources/Posta/AboutView.swift">
import SwiftUI
struct AboutView: View {
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 30) {
                    // App Icon and Info
                    VStack(spacing: 16) {
                        Image(systemName: "envelope.fill")
                            .font(.system(size: 80))
                            .foregroundColor(.blue)
                            .padding()
                            .background(Color.blue.opacity(0.1))
                            .cornerRadius(20)
                        Text("Posta")
                            .font(.largeTitle)
                            .fontWeight(.bold)
                        Text("Version 1.0.0")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        Text("A modern Nostr client for iOS")
                            .font(.body)
                            .foregroundColor(.secondary)
                    }
                    .padding(.top, 40)
                    // Links Section
                    VStack(spacing: 12) {
                        LinkRow(
                            icon: "globe",
                            title: "Website",
                            subtitle: "posta.app",
                            action: openWebsite
                        )
                        LinkRow(
                            icon: "envelope",
                            title: "Contact",
                            subtitle: "support@posta.app",
                            action: sendEmail
                        )
                        LinkRow(
                            icon: "doc.text",
                            title: "Terms of Service",
                            subtitle: "View our terms",
                            action: openTerms
                        )
                        LinkRow(
                            icon: "hand.raised",
                            title: "Privacy Policy",
                            subtitle: "How we handle your data",
                            action: openPrivacy
                        )
                        LinkRow(
                            icon: "sparkles",
                            title: "What's New",
                            subtitle: "Latest features and fixes",
                            action: openChangelog
                        )
                    }
                    .padding(.horizontal)
                    // Credits
                    VStack(spacing: 16) {
                        Text("Built with")
                            .font(.headline)
                        HStack(spacing: 20) {
                            VStack {
                                Image(systemName: "swift")
                                    .font(.title)
                                    .foregroundColor(.orange)
                                Text("Swift")
                                    .font(.caption)
                            }
                            VStack {
                                Image(systemName: "square.stack.3d.up")
                                    .font(.title)
                                    .foregroundColor(.blue)
                                Text("SwiftUI")
                                    .font(.caption)
                            }
                            VStack {
                                Image(systemName: "bolt.fill")
                                    .font(.title)
                                    .foregroundColor(.purple)
                                Text("NDKSwift")
                                    .font(.caption)
                            }
                        }
                    }
                    .padding(.vertical)
                    // Footer
                    VStack(spacing: 8) {
                        Text("Made with  for the Nostr community")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Text(" 2024 Posta. All rights reserved.")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                    .padding(.bottom, 40)
                }
            }
            .navigationBarItems(trailing: Button("Done") { dismiss() })
        }
    }
    private func openWebsite() {
        if let url = URL(string: "https://posta.app") {
            UIApplication.shared.open(url)
        }
    }
    private func sendEmail() {
        if let url = URL(string: "mailto:support@posta.app") {
            UIApplication.shared.open(url)
        }
    }
    private func openTerms() {
        if let url = URL(string: "https://posta.app/terms") {
            UIApplication.shared.open(url)
        }
    }
    private func openPrivacy() {
        if let url = URL(string: "https://posta.app/privacy") {
            UIApplication.shared.open(url)
        }
    }
    private func openChangelog() {
        if let url = URL(string: "https://posta.app/changelog") {
            UIApplication.shared.open(url)
        }
    }
}
struct LinkRow: View {
    let icon: String
    let title: String
    let subtitle: String
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.title3)
                    .foregroundColor(.blue)
                    .frame(width: 30)
                VStack(alignment: .leading, spacing: 2) {
                    Text(title)
                        .font(.subheadline)
                        .foregroundColor(.primary)
                    Text(subtitle)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding(.vertical, 8)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
</file>

<file path="Sources/Posta/AccountSettingsView.swift">
import SwiftUI
import NDKSwift
struct AccountSettingsView: View {
    @Environment(NDKAuthManager.self) var authManager
    @State private var showingAddAccount = false
    @State private var showingDeleteConfirmation = false
    @State private var sessionToDelete: NDKSession?
    @Environment(\.dismiss) var dismiss
    var body: some View {
        List {
            // Current Sessions
            Section("My Accounts") {
                ForEach(authManager.availableSessions, id: \.id) { session in
                    SessionRow(
                        session: session,
                        isActive: session.id == authManager.activeSession?.id,
                        onTap: {
                            Task {
                                try? await authManager.switchToSession(session)
                            }
                        },
                        onDelete: {
                            sessionToDelete = session
                            showingDeleteConfirmation = true
                        }
                    )
                }
            }
            // Add Account
            Section {
                Button(action: { showingAddAccount = true }) {
                    HStack {
                        Image(systemName: "plus.circle.fill")
                            .foregroundColor(.blue)
                        Text("Add Account")
                    }
                }
            }
            // Sign Out
            if authManager.activeSession != nil {
                Section {
                    Button(action: {
                        authManager.logout()
                        dismiss()
                    }) {
                        HStack {
                            Image(systemName: "arrow.right.square.fill")
                                .foregroundColor(.red)
                            Text("Sign Out")
                                .foregroundColor(.red)
                        }
                    }
                }
            }
        }
        .navigationTitle("Account Settings")
        .navigationBarTitleDisplayMode(.inline)
        .sheet(isPresented: $showingAddAccount) {
            PostaAuthView()
        }
        .alert("Delete Account", isPresented: $showingDeleteConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let session = sessionToDelete {
                    Task {
                        try? await authManager.deleteSession(session)
                    }
                }
            }
        } message: {
            Text("Are you sure you want to delete this account? This action cannot be undone.")
        }
    }
}
struct SessionRow: View {
    let session: NDKSession
    let isActive: Bool
    let onTap: () -> Void
    let onDelete: () -> Void
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                HStack {
                    Text(session.profileName ?? String(session.pubkey.prefix(8)) + "...")
                        .font(.headline)
                    if isActive {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                            .font(.caption)
                    }
                }
                HStack {
                    Image(systemName: session.signerType == "bunker" ? "lock.shield.fill" : "key.fill")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text(session.signerType.capitalized)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    if session.requiresBiometric {
                        Image(systemName: "faceid")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }
            Spacer()
            Button(action: onDelete) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
            .buttonStyle(BorderlessButtonStyle())
        }
        .contentShape(Rectangle())
        .onTapGesture {
            onTap()
        }
        .padding(.vertical, 4)
    }
}
#Preview {
    NavigationStack {
        AccountSettingsView()
            .environment(NDKAuthManager.shared)
    }
}
</file>

<file path="Sources/Posta/AdvancedSettingsView.swift">
import SwiftUI
struct AdvancedSettingsView: View {
    @AppStorage("auto_translate") private var autoTranslate = false
    @AppStorage("show_dev_options") private var showDevOptions = false
    @AppStorage("cache_size_mb") private var cacheSizeMB = 100
    @AppStorage("connection_timeout") private var connectionTimeout = 30
    @AppStorage("max_events_per_sub") private var maxEventsPerSub = 500
    @State private var showingCacheClear = false
    @State private var showingExportKeys = false
    var body: some View {
        List {
            // Performance
            Section {
                HStack {
                    Text("Cache Size")
                    Spacer()
                    Text("\(cacheSizeMB) MB")
                        .foregroundColor(.secondary)
                }
                Slider(value: Binding(
                    get: { Double(cacheSizeMB) },
                    set: { cacheSizeMB = Int($0) }
                ), in: 50...500, step: 50)
                Button(action: { showingCacheClear = true }) {
                    HStack {
                        Text("Clear Cache")
                        Spacer()
                        Text("~45 MB")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            } header: {
                Text("Performance")
            }
            // Network
            Section {
                HStack {
                    Text("Connection Timeout")
                    Spacer()
                    Text("\(connectionTimeout)s")
                        .foregroundColor(.secondary)
                }
                Slider(value: Binding(
                    get: { Double(connectionTimeout) },
                    set: { connectionTimeout = Int($0) }
                ), in: 10...60, step: 5)
                HStack {
                    Text("Max Events per Subscription")
                    Spacer()
                    Text("\(maxEventsPerSub)")
                        .foregroundColor(.secondary)
                }
                Slider(value: Binding(
                    get: { Double(maxEventsPerSub) },
                    set: { maxEventsPerSub = Int($0) }
                ), in: 100...1000, step: 100)
            } header: {
                Text("Network")
            }
            // Features
            Section {
                Toggle(isOn: $autoTranslate) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Auto-Translate")
                        Text("Automatically translate posts in foreign languages")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            } header: {
                Text("Features")
            }
            // Developer Options
            Section {
                Toggle(isOn: $showDevOptions) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Developer Mode")
                        Text("Show advanced debugging options")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                if showDevOptions {
                    NavigationLink(destination: DeveloperOptionsView()) {
                        Label("Developer Options", systemImage: "hammer")
                    }
                }
            } header: {
                Text("Developer")
            }
            // Data Management
            Section {
                Button(action: { showingExportKeys = true }) {
                    HStack {
                        Image(systemName: "square.and.arrow.up")
                        Text("Export Keys")
                    }
                }
                NavigationLink(destination: DataExportView()) {
                    HStack {
                        Image(systemName: "archivebox")
                        Text("Export All Data")
                    }
                }
            } header: {
                Text("Data Management")
            }
        }
        .navigationTitle("Advanced")
        .navigationBarTitleDisplayMode(.large)
        .confirmationDialog(
            "Clear Cache",
            isPresented: $showingCacheClear,
            titleVisibility: .visible
        ) {
            Button("Clear", role: .destructive) {
                clearCache()
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("This will remove all cached data. The app will need to re-download content.")
        }
        .alert("Export Keys", isPresented: $showingExportKeys) {
            Button("Copy to Clipboard") {
                exportKeys()
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("Your private keys will be copied to the clipboard. Make sure to store them securely.")
        }
    }
    private func clearCache() {
        // Implementation for clearing cache
    }
    private func exportKeys() {
        // Implementation for exporting keys
    }
}
struct DeveloperOptionsView: View {
    @AppStorage("debug_logging") private var debugLogging = false
    @AppStorage("show_event_ids") private var showEventIds = false
    @AppStorage("show_raw_events") private var showRawEvents = false
    var body: some View {
        List {
            Section {
                Toggle("Debug Logging", isOn: $debugLogging)
                Toggle("Show Event IDs", isOn: $showEventIds)
                Toggle("Show Raw Events", isOn: $showRawEvents)
            }
            Section {
                NavigationLink(destination: EventLogView()) {
                    Label("Event Log", systemImage: "doc.text")
                }
                NavigationLink(destination: RelayLogView()) {
                    Label("Relay Log", systemImage: "network")
                }
            }
        }
        .navigationTitle("Developer Options")
    }
}
struct DataExportView: View {
    var body: some View {
        List {
            Text("Export functionality coming soon")
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 40)
        }
        .navigationTitle("Export Data")
    }
}
struct EventLogView: View {
    var body: some View {
        List {
            Text("Event log coming soon")
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 40)
        }
        .navigationTitle("Event Log")
    }
}
struct RelayLogView: View {
    var body: some View {
        List {
            Text("Relay log coming soon")
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 40)
        }
        .navigationTitle("Relay Log")
    }
}
</file>

<file path="Sources/Posta/AppearanceSettingsView.swift">
import SwiftUI
struct AppearanceSettingsView: View {
    @ObservedObject var themeManager: ThemeManager
    @State private var selectedTheme: ThemeManager.Theme
    init(themeManager: ThemeManager) {
        self.themeManager = themeManager
        self._selectedTheme = State(initialValue: themeManager.currentTheme)
    }
    var body: some View {
        List {
            // Theme Selection
            Section("Theme") {
                ForEach(ThemeManager.Theme.allCases, id: \.self) { theme in
                    ThemeRow(
                        theme: theme,
                        isSelected: selectedTheme == theme,
                        onSelect: {
                            selectedTheme = theme
                            themeManager.currentTheme = theme
                        }
                    )
                }
            }
            // Preview Section
            Section("Preview") {
                VStack(spacing: 16) {
                    // Sample Card
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Circle()
                                .fill(Color.gray.opacity(0.3))
                                .frame(width: 40, height: 40)
                            VStack(alignment: .leading) {
                                Text("Sample User")
                                    .font(.headline)
                                Text("@sampleuser")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                            Button(action: {}) {
                                Text("Follow")
                                    .font(.caption)
                                    .fontWeight(.semibold)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(Color.blue)
                                    .foregroundColor(.white)
                                    .cornerRadius(15)
                            }
                        }
                        Text("This is how your content will appear with the selected theme. The app automatically adjusts colors and contrast for optimal readability.")
                            .font(.subheadline)
                            .foregroundColor(.primary)
                        HStack(spacing: 20) {
                            Button(action: {}) {
                                Image(systemName: "heart")
                                    .foregroundColor(.secondary)
                            }
                            Button(action: {}) {
                                Image(systemName: "bubble.left")
                                    .foregroundColor(.secondary)
                            }
                            Button(action: {}) {
                                Image(systemName: "arrow.2.squarepath")
                                    .foregroundColor(.secondary)
                            }
                        }
                        .font(.callout)
                    }
                    .padding()
                    .background(Color(.systemBackground))
                    .cornerRadius(12)
                    .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
                }
                .padding(.vertical)
            }
            // Additional Options
            Section("Display") {
                HStack {
                    Text("App Icon")
                    Spacer()
                    Text("Default")
                        .foregroundColor(.secondary)
                    Image(systemName: "chevron.right")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                HStack {
                    Text("Text Size")
                    Spacer()
                    Text("Default")
                        .foregroundColor(.secondary)
                    Image(systemName: "chevron.right")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .navigationTitle("Appearance")
        .navigationBarTitleDisplayMode(.large)
    }
}
struct ThemeRow: View {
    let theme: ThemeManager.Theme
    let isSelected: Bool
    let onSelect: () -> Void
    var body: some View {
        Button(action: onSelect) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(theme.rawValue)
                        .font(.headline)
                    Text(themeDescription)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.blue)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
    private var themeDescription: String {
        switch theme {
        case .system:
            return "Automatically match your device settings"
        case .light:
            return "Always use light appearance"
        case .dark:
            return "Always use dark appearance"
        }
    }
}
</file>

<file path="Sources/Posta/ComposeView.swift">
import SwiftUI
import NDKSwift
struct ComposeView: View {
    @Environment(\.dismiss) var dismiss
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @State private var content = ""
    @State private var isPublishing = false
    @State private var publishError: Error?
    @State private var confirmationState: EventConfirmationState?
    @State private var publishedEventId: String?
    @State private var monitoringTask: Task<Void, Never>?
    @FocusState private var isTextFieldFocused: Bool
    private let maxCharacters = 280
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button("Cancel") {
                        dismiss()
                    }
                    .disabled(isPublishing)
                    Spacer()
                    publishButton
                }
                .padding()
                .background(Color(.systemBackground))
                Divider()
                // Compose area
                ScrollView {
                    VStack(alignment: .leading, spacing: 16) {
                        // Text editor
                        TextEditor(text: $content)
                            .font(.body)
                            .padding(4)
                            .background(Color(.secondarySystemBackground))
                            .cornerRadius(8)
                            .frame(minHeight: 150)
                            .focused($isTextFieldFocused)
                        // Character count
                        HStack {
                            Spacer()
                            Text("\(content.count)/\(maxCharacters)")
                                .font(.caption)
                                .foregroundColor(content.count > maxCharacters ? .red : .secondary)
                        }
                        // Publishing status
                        if isPublishing || confirmationState != nil {
                            publishingStatusView
                        }
                        // Error message
                        if let error = publishError {
                            ErrorBanner(error: error)
                                .padding(.top, 8)
                        }
                    }
                    .padding()
                }
            }
            .navigationTitle("New Post")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarHidden(true)
        }
        .onAppear {
            isTextFieldFocused = true
        }
        .onDisappear {
            monitoringTask?.cancel()
        }
    }
    private var publishButton: some View {
        Button(action: {
            Task {
                await publishNote()
            }
        }) {
            Group {
                if isPublishing {
                    HStack(spacing: 6) {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(0.8)
                        Text("Publishing...")
                    }
                } else {
                    Text("Post")
                        .fontWeight(.semibold)
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(isPublishEnabled ? Color.accentColor : Color.gray)
            .foregroundColor(.white)
            .cornerRadius(20)
        }
        .disabled(!isPublishEnabled || isPublishing)
    }
    private var isPublishEnabled: Bool {
        !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        content.count <= maxCharacters
    }
    private var publishingStatusView: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                switch confirmationState {
                case .optimistic:
                    Image(systemName: "arrow.up.circle")
                        .foregroundColor(.orange)
                    Text("Sending to relays...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                case .confirmed(let relay):
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                    Text("Confirmed by \(relay)")
                        .font(.caption)
                        .foregroundColor(.green)
                case .none:
                    if isPublishing {
                        Image(systemName: "arrow.up.circle")
                            .foregroundColor(.blue)
                        Text("Preparing...")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                Spacer()
            }
            .padding()
            .background(Color(.tertiarySystemFill))
            .cornerRadius(8)
        }
    }
    private func publishNote() async {
        guard let ndk = ndkManager.ndk,
              let signer = authManager.activeSigner else {
            publishError = NostrError.signerRequired
            return
        }
        isPublishing = true
        publishError = nil
        confirmationState = nil
        do {
            // Build and sign the event
            let event = try await NDKEventBuilder(ndk: ndk)
                .content(content)
                .kind(EventKind.textNote)
                .build(signer: signer)
            // Store the event ID for monitoring
            publishedEventId = event.id
            // Start monitoring confirmation state
            monitoringTask = Task {
                await monitorConfirmationState(eventId: event.id)
            }
            // Publish with optimistic dispatch
            let publishedRelays = try await ndk.publish(event)
            print("Published to \(publishedRelays.count) relays")
            // Wait a moment for final confirmation
            try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
            // Check final state
            if case .confirmed = confirmationState {
                // Success - dismiss after brief delay
                try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
                await MainActor.run {
                    dismiss()
                }
            }
        } catch {
            publishError = error
            isPublishing = false
        }
    }
    private func monitorConfirmationState(eventId: String) async {
        guard let cache = ndkManager.ndk?.cache else { return }
        // Monitor confirmation state changes
        while !Task.isCancelled {
            if let state = await cache.getEventConfirmationState(eventId: eventId) {
                await MainActor.run {
                    self.confirmationState = state
                    // Stop publishing indicator once we have any confirmation
                    if case .confirmed = state {
                        self.isPublishing = false
                    }
                }
                // Stop monitoring once fully confirmed
                if case .confirmed = state {
                    break
                }
            }
            // Check every 500ms
            try? await Task.sleep(nanoseconds: 500_000_000)
        }
    }
}
#Preview {
    ComposeView()
        .environment(NDKAuthManager.shared)
        .environment(NDKManager.shared)
}
</file>

<file path="Sources/Posta/ContentView.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
struct ContentView: View {
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @State private var hasCompletedWelcome = UserDefaults.standard.bool(forKey: "hasCompletedWelcome")
    var body: some View {
        Group {
            if authManager.isAuthenticated {
                // Authenticated content
                MainTabView()
            } else if !hasCompletedWelcome {
                // Show welcome screen for first-time users
                PostaWelcomeView()
                    .onReceive(NotificationCenter.default.publisher(for: Notification.Name("WelcomeCompleted"))) { _ in
                        UserDefaults.standard.set(true, forKey: "hasCompletedWelcome")
                        hasCompletedWelcome = true
                    }
            } else {
                // Authentication content
                PostaAuthView()
            }
        }
        .environment(\.ndk, ndkManager.ndk)
    }
}
struct MainTabView: View {
    var body: some View {
        TabView {
            HomeView()
                .tabItem {
                    Image(systemName: "house")
                    Text("Home")
                }
            ProfileView(pubkey: nil)
                .tabItem {
                    Image(systemName: "person")
                    Text("Profile")
                }
            SettingsView()
                .tabItem {
                    Image(systemName: "gear")
                    Text("Settings")
                }
        }
    }
}
#Preview {
    ContentView()
        .environment(NDKAuthManager.shared)
        .environment(NDKManager.shared)
        .environment(RelayManager())
}
</file>

<file path="Sources/Posta/DesignSystem.swift">
import SwiftUI
// MARK: - Design System Colors
struct PostaColors {
    // Primary gradient colors
    static let primaryGradient = Gradient(colors: [
        Color(red: 0.6, green: 0.2, blue: 0.9),  // Purple
        Color(red: 0.8, green: 0.3, blue: 0.6),  // Pink
        Color(red: 0.9, green: 0.4, blue: 0.5)   // Coral
    ])
    // Secondary gradient colors
    static let secondaryGradient = Gradient(colors: [
        Color(red: 0.2, green: 0.6, blue: 0.9),  // Blue
        Color(red: 0.3, green: 0.8, blue: 0.8),  // Cyan
    ])
    // Dark gradient background
    static let darkBackgroundGradient = Gradient(colors: [
        Color(red: 0.05, green: 0.02, blue: 0.08),
        Color(red: 0.02, green: 0.01, blue: 0.04),
        Color.black
    ])
    // Accent colors
    static let electricPurple = Color(red: 0.7, green: 0.3, blue: 0.9)
    static let glowPink = Color(red: 0.9, green: 0.3, blue: 0.6)
    static let neonBlue = Color(red: 0.3, green: 0.6, blue: 1.0)
    // UI colors
    static let surfaceColor = Color.white.opacity(0.08)
    static let borderColor = Color.white.opacity(0.2)
    static let textPrimary = Color.white
    static let textSecondary = Color.white.opacity(0.7)
    static let textTertiary = Color.white.opacity(0.5)
}
// MARK: - Button Styles
struct PostaPrimaryButtonStyle: ButtonStyle {
    let isEnabled: Bool
    init(isEnabled: Bool = true) {
        self.isEnabled = isEnabled
    }
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.system(size: 18, weight: .semibold))
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .frame(height: 56)
            .background(
                LinearGradient(
                    gradient: isEnabled ? PostaColors.primaryGradient : Gradient(colors: [Color.gray, Color.gray.opacity(0.8)]),
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .clipShape(RoundedRectangle(cornerRadius: 16))
            .shadow(
                color: isEnabled ? PostaColors.electricPurple.opacity(0.3) : Color.clear,
                radius: configuration.isPressed ? 5 : 10,
                x: 0,
                y: configuration.isPressed ? 2 : 4
            )
            .scaleEffect(configuration.isPressed ? 0.97 : 1)
            .animation(.spring(response: 0.3, dampingFraction: 0.8), value: configuration.isPressed)
    }
}
struct PostaSecondaryButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.system(size: 18, weight: .semibold))
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .frame(height: 56)
            .background(PostaColors.surfaceColor)
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(
                        LinearGradient(
                            gradient: PostaColors.primaryGradient,
                            startPoint: .leading,
                            endPoint: .trailing
                        ),
                        lineWidth: 1.5
                    )
            )
            .clipShape(RoundedRectangle(cornerRadius: 16))
            .scaleEffect(configuration.isPressed ? 0.97 : 1)
            .animation(.spring(response: 0.3, dampingFraction: 0.8), value: configuration.isPressed)
    }
}
struct PostaTextButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.system(size: 16, weight: .medium))
            .foregroundColor(PostaColors.textSecondary)
            .opacity(configuration.isPressed ? 0.6 : 1)
            .animation(.easeOut(duration: 0.1), value: configuration.isPressed)
    }
}
// MARK: - Text Field Styles
struct PostaTextFieldStyle: TextFieldStyle {
    func _body(configuration: TextField<Self._Label>) -> some View {
        configuration
            .font(.system(size: 16))
            .padding(18)
            .background(PostaColors.surfaceColor)
            .foregroundColor(.white)
            .accentColor(PostaColors.electricPurple)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(PostaColors.borderColor, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: 12))
    }
}
// MARK: - Card Styles
struct PostaCardBackground: ViewModifier {
    let isHighlighted: Bool
    init(isHighlighted: Bool = false) {
        self.isHighlighted = isHighlighted
    }
    func body(content: Content) -> some View {
        content
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(PostaColors.surfaceColor)
                    .overlay(
                        RoundedRectangle(cornerRadius: 20)
                            .stroke(
                                isHighlighted ? 
                                LinearGradient(gradient: PostaColors.primaryGradient, startPoint: .topLeading, endPoint: .bottomTrailing) :
                                LinearGradient(gradient: Gradient(colors: [PostaColors.borderColor]), startPoint: .leading, endPoint: .trailing),
                                lineWidth: isHighlighted ? 1.5 : 1
                            )
                    )
                    .shadow(
                        color: isHighlighted ? PostaColors.electricPurple.opacity(0.2) : Color.black.opacity(0.3),
                        radius: isHighlighted ? 15 : 8,
                        x: 0,
                        y: isHighlighted ? 8 : 4
                    )
            )
    }
}
// MARK: - Glow Effects
struct PostaGlowEffect: ViewModifier {
    let color: Color
    let radius: CGFloat
    init(color: Color = PostaColors.electricPurple, radius: CGFloat = 20) {
        self.color = color
        self.radius = radius
    }
    func body(content: Content) -> some View {
        content
            .background(
                content
                    .blur(radius: radius)
                    .opacity(0.5)
                    .blendMode(.plusLighter)
            )
    }
}
// MARK: - Animation Helpers
struct PostaPulseAnimation: ViewModifier {
    @State private var scale: CGFloat = 1
    let minScale: CGFloat
    let maxScale: CGFloat
    let duration: Double
    init(minScale: CGFloat = 0.95, maxScale: CGFloat = 1.05, duration: Double = 2) {
        self.minScale = minScale
        self.maxScale = maxScale
        self.duration = duration
    }
    func body(content: Content) -> some View {
        content
            .scaleEffect(scale)
            .onAppear {
                withAnimation(.easeInOut(duration: duration).repeatForever(autoreverses: true)) {
                    scale = maxScale
                }
            }
    }
}
struct PostaShimmerEffect: ViewModifier {
    @State private var phase: CGFloat = 0
    func body(content: Content) -> some View {
        content
            .overlay(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color.white.opacity(0),
                        Color.white.opacity(0.3),
                        Color.white.opacity(0)
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .rotationEffect(.degrees(20))
                .offset(x: phase * 400 - 200)
                .mask(content)
                .allowsHitTesting(false)
            )
            .onAppear {
                withAnimation(.linear(duration: 2).repeatForever(autoreverses: false)) {
                    phase = 1
                }
            }
    }
}
// MARK: - View Extensions
extension View {
    func postaCard(isHighlighted: Bool = false) -> some View {
        modifier(PostaCardBackground(isHighlighted: isHighlighted))
    }
    func postaGlow(_ color: Color = PostaColors.electricPurple, radius: CGFloat = 20) -> some View {
        modifier(PostaGlowEffect(color: color, radius: radius))
    }
    func postaPulse(minScale: CGFloat = 0.95, maxScale: CGFloat = 1.05, duration: Double = 2) -> some View {
        modifier(PostaPulseAnimation(minScale: minScale, maxScale: maxScale, duration: duration))
    }
    func postaShimmer() -> some View {
        modifier(PostaShimmerEffect())
    }
}
// MARK: - Common Components
struct PostaSectionHeader: View {
    let title: String
    let subtitle: String?
    init(_ title: String, subtitle: String? = nil) {
        self.title = title
        self.subtitle = subtitle
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.system(size: 24, weight: .bold))
                .foregroundColor(PostaColors.textPrimary)
            if let subtitle = subtitle {
                Text(subtitle)
                    .font(.system(size: 16))
                    .foregroundColor(PostaColors.textSecondary)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}
struct PostaLoadingView: View {
    var body: some View {
        VStack(spacing: 16) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: PostaColors.electricPurple))
                .scaleEffect(1.2)
            Text("Loading...")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(PostaColors.textSecondary)
        }
        .padding(40)
        .postaCard()
    }
}
// MARK: - Background Patterns
struct PostaBackgroundView: View {
    @State private var animationPhase: CGFloat = 0
    var body: some View {
        ZStack {
            // Base gradient
            LinearGradient(
                gradient: PostaColors.darkBackgroundGradient,
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated mesh gradient overlay
            GeometryReader { geometry in
                ForEach(0..<3) { index in
                    Circle()
                        .fill(
                            RadialGradient(
                                gradient: Gradient(colors: [
                                    PostaColors.electricPurple.opacity(0.3),
                                    PostaColors.glowPink.opacity(0.2),
                                    Color.clear
                                ]),
                                center: .center,
                                startRadius: 50,
                                endRadius: 200
                            )
                        )
                        .frame(width: 300, height: 300)
                        .blur(radius: 40)
                        .offset(
                            x: Foundation.cos(animationPhase + Double(index) * 2) * geometry.size.width * 0.3,
                            y: Foundation.sin(animationPhase + Double(index) * 2) * geometry.size.height * 0.3
                        )
                }
            }
            .onAppear {
                withAnimation(.linear(duration: 20).repeatForever(autoreverses: false)) {
                    animationPhase = .pi * 2
                }
            }
        }
        .ignoresSafeArea()
    }
}
// MARK: - Electric Effect Shape
struct ElectricField: Shape {
    let points: Int
    init(points: Int = 5) {
        self.points = points
    }
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        for i in 0..<points {
            let angle = Double(i) * (2 * .pi / Double(points))
            let endPoint = CGPoint(
                x: center.x + Foundation.cos(angle) * rect.width * 0.4,
                y: center.y + Foundation.sin(angle) * rect.height * 0.4
            )
            path.move(to: center)
            // Create jagged lightning path
            let segments = 6
            var currentPoint = center
            for j in 1...segments {
                let progress = CGFloat(j) / CGFloat(segments)
                let baseX = center.x + (endPoint.x - center.x) * progress
                let baseY = center.y + (endPoint.y - center.y) * progress
                let offsetRange: CGFloat = j == segments ? 0 : 15
                let offsetX = CGFloat.random(in: -offsetRange...offsetRange)
                let offsetY = CGFloat.random(in: -offsetRange...offsetRange)
                let nextPoint = CGPoint(x: baseX + offsetX, y: baseY + offsetY)
                path.addLine(to: j == segments ? endPoint : nextPoint)
                currentPoint = nextPoint
            }
        }
        return path
    }
}
// MARK: - Electric Field View
struct ElectricFieldView: View {
    @State private var regenerateTrigger = false
    @State private var opacity: Double = 0
    var body: some View {
        TimelineView(.animation(minimumInterval: 0.5)) { timeline in
            Canvas { context, size in
                for _ in 0..<3 {
                    var electricPath = Path()
                    let field = ElectricField(points: Int.random(in: 4...7))
                    electricPath = field.path(in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
                    context.stroke(
                        electricPath,
                        with: .linearGradient(
                            Gradient(colors: [
                                PostaColors.electricPurple,
                                PostaColors.glowPink,
                                PostaColors.neonBlue
                            ]),
                            startPoint: CGPoint(x: 0, y: 0),
                            endPoint: CGPoint(x: size.width, y: size.height)
                        ),
                        lineWidth: 2
                    )
                }
            }
            .blur(radius: 3)
            .opacity(opacity)
            .onAppear {
                withAnimation(.easeIn(duration: 0.3)) {
                    opacity = 1
                }
            }
            .onChange(of: timeline.date) { _ in
                withAnimation(.easeOut(duration: 0.2)) {
                    opacity = 0
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    withAnimation(.easeIn(duration: 0.3)) {
                        opacity = 1
                    }
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/HomeView.swift">
import SwiftUI
import NDKSwift
struct HomeView: View {
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @State private var selectedProfile: String?
    @State private var selectedThread: NDKEvent?
    @State private var replyTracker: ReplyTracker?
    @State private var showingCompose = false
    // Data source for notes
    @State private var notesDataSource: SessionNotesDataSource?
    @State private var newNotesCount: Int = 0
    @State private var showContent = false
    var body: some View {
        NavigationView {
            ZStack {
                // Animated gradient background
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(.systemBackground),
                        Color.purple.opacity(0.02),
                        Color(.systemBackground)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Elegant header
                    headerView
                    // Main content - always show UI immediately
                    if notesDataSource?.notes.isEmpty == true {
                        emptyStateView
                    } else {
                        chatListView
                    }
                }
                // Floating compose button
                VStack {
                    Spacer()
                    HStack {
                        Spacer()
                        FloatingActionButton(icon: "square.and.pencil") {
                            showingCompose = true
                        }
                        .padding(.trailing, 20)
                        .padding(.bottom, 20)
                    }
                }
            }
            .navigationBarHidden(true)
        }
        .sheet(item: $selectedProfile) { pubkey in
            ProfileView(pubkey: pubkey)
        }
        .sheet(item: $selectedThread) { event in
            ThreadView(rootEvent: event)
        }
        .sheet(isPresented: $showingCompose) {
            ComposeView()
        }
        .onAppear {
            print(" [HomeView] onAppear called")
            print(" [HomeView] ndkManager.ndk = \(ndkManager.ndk != nil ? "Available" : "NIL")")
            // Always show content immediately - no loading states
            showContent = true
            if let ndk = ndkManager.ndk {
                print(" [HomeView] ndk.signer = \(ndk.signer != nil ? "Available" : "NIL")")
                // Create data source if not already created
                if notesDataSource == nil {
                    notesDataSource = SessionNotesDataSource(ndk: ndk)
                }
            }
        }
        .task {
            // Wait for data source to be created
            while notesDataSource == nil {
                try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
            }
            guard let dataSource = notesDataSource else { return }
            // Monitor session data changes
            for await _ in dataSource.$sessionData.values {
                if let sessionData = dataSource.sessionData, replyTracker == nil {
                    replyTracker = ReplyTracker(ndk: dataSource.ndk, following: sessionData.followList)
                    print(" [HomeView] Reply tracker initialized")
                }
            }
        }
        .onDisappear {
            replyTracker?.stopAllTracking()
        }
    }
    private var headerView: some View {
        ZStack {
            // Animated header background
            AnimatedHeaderBackground()
            // Subtle background blur effect
            VisualEffectBlur(blurStyle: .systemUltraThinMaterial)
                .opacity(0.8)
            VStack(spacing: 0) {
                HStack(spacing: 12) {
                    HStack(spacing: 12) {
                        PostaLogoView(size: 32, color: .purple)
                        Text("Messages")
                            .font(.system(size: 28, weight: .bold, design: .rounded))
                            .foregroundStyle(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.primary,
                                        Color.primary.opacity(0.8)
                                    ]),
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                    }
                    Spacer()
                    // Sync button with animation
                    Button(action: {
                        Task {
                            await notesDataSource?.refresh()
                        }
                    }) {
                        ZStack {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            Color.purple.opacity(0.1),
                                            Color.purple.opacity(0.05)
                                        ]),
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 40, height: 40)
                            Image(systemName: "arrow.clockwise")
                                .font(.system(size: 16, weight: .medium))
                                .foregroundColor(.purple)
                                .rotationEffect(.degrees(notesDataSource?.isLoading == true ? 360 : 0))
                                .animation(.linear(duration: 1).repeatForever(autoreverses: false), value: notesDataSource?.isLoading == true)
                        }
                    }
                    .disabled(notesDataSource?.isLoading == true)
                    .scaleEffect(notesDataSource?.isLoading == true ? 0.95 : 1)
                    .animation(.easeInOut(duration: 0.2), value: notesDataSource?.isLoading == true)
                    // Profile button with gradient
                    Button(action: {
                        if let activeSession = authManager.activeSession {
                            selectedProfile = activeSession.pubkey
                        }
                    }) {
                        ZStack {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            Color.purple.opacity(0.1),
                                            Color.purple.opacity(0.05)
                                        ]),
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 40, height: 40)
                            Image(systemName: "person.circle.fill")
                                .font(.system(size: 20, weight: .regular))
                                .foregroundColor(.purple)
                        }
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 10)
                // Connection status - show inline without blocking
                if let error = notesDataSource?.error {
                    ErrorBanner(error: error)
                        .padding(.horizontal, 16)
                        .padding(.bottom, 6)
                        .transition(.asymmetric(
                            insertion: .move(edge: .top).combined(with: .opacity),
                            removal: .move(edge: .top).combined(with: .opacity)
                        ))
                        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: error.localizedDescription)
                }
                // Sync status
                if notesDataSource?.hasEOSE == true {
                    Text("Synced")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .padding(.bottom, 6)
                }
            }
        }
        .frame(height: notesDataSource?.error != nil ? 90 : 70)
        .shadow(color: Color.black.opacity(0.03), radius: 3, x: 0, y: 1)
    }
    private var emptyStateView: some View {
        VStack(spacing: 24) {
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.purple.opacity(0.1),
                                Color.purple.opacity(0.05)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 120, height: 120)
                    .blur(radius: 20)
                Image(systemName: "envelope.open")
                    .font(.system(size: 56))
                    .foregroundStyle(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.purple,
                                Color.purple.opacity(0.7)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .symbolEffect(.bounce, value: true)
            }
            VStack(spacing: 12) {
                Text("No messages yet")
                    .font(.system(size: 22, weight: .semibold))
                    .foregroundColor(.primary)
                Text("Messages from people you follow\nwill appear here")
                    .font(.system(size: 16))
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .lineSpacing(4)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .offset(y: -40)
    }
    private var chatListView: some View {
        ZStack(alignment: .top) {
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(spacing: 0) {
                        // Invisible anchor for scrolling to top
                        Color.clear
                            .frame(height: 0)
                            .id("top")
                            .onAppear {
                                // User is viewing the top of the list
                                if newNotesCount > 0 {
                                    resetNewNotesCount()
                                }
                            }
                        ForEach(Array((notesDataSource?.notes ?? []).enumerated()), id: \.element.id) { index, event in
                            ChatRowView(
                                event: event,
                                replyTracker: replyTracker,
                                onTap: {
                                    selectedThread = event
                                },
                                onAvatarTap: {
                                    selectedProfile = event.pubkey
                                }
                            )
                            .animation(.spring(response: 0.5, dampingFraction: 0.8).delay(Double(index) * 0.05), value: showContent)
                        }
                    }
                }
                .scrollIndicators(.hidden)
                // New notes indicator
                if newNotesCount > 0 {
                    Button(action: {
                        // Scroll to top and reset counter
                        withAnimation {
                            proxy.scrollTo("top", anchor: .top)
                        }
                        resetNewNotesCount()
                    }) {
                    HStack(spacing: 6) {
                        Image(systemName: "arrow.up")
                            .font(.system(size: 12, weight: .semibold))
                        Text("\(newNotesCount) new")
                            .font(.system(size: 13, weight: .semibold))
                    }
                    .foregroundColor(.white)
                    .padding(.horizontal, 14)
                    .padding(.vertical, 8)
                    .background(
                        Capsule()
                            .fill(Color.accentColor)
                            .shadow(color: Color.accentColor.opacity(0.3), radius: 6, x: 0, y: 3)
                    )
                }
                .padding(.top, 8)
                .transition(.asymmetric(
                    insertion: .scale.combined(with: .opacity),
                    removal: .scale.combined(with: .opacity)
                ))
                .animation(.spring(response: 0.3, dampingFraction: 0.8), value: newNotesCount)
                }
            }
        }
    }
    // MARK: - Helper Methods
    private func resetNewNotesCount() {
        newNotesCount = 0
    }
}
struct ChatRowView: View {
    let event: NDKEvent
    let replyTracker: ReplyTracker?
    let onTap: () -> Void
    let onAvatarTap: () -> Void
    @Environment(NDKManager.self) var ndkManager
    @State private var profile: NDKUserProfile?
    @State private var isPressed = false
    @State private var profileTask: Task<Void, Never>?
    @State private var replyInfo: ReplyTracker.ReplyInfo?
    @State private var pollingTask: Task<Void, Never>?
    @State private var showContent = false
    var body: some View {
        ZStack {
            // Card background
            MessageCard(
                isPressed: isPressed,
                hasUnread: false
            )
            .padding(.horizontal, 12)
            .padding(.vertical, 4)
            HStack(alignment: .top, spacing: 0) {
                // Avatar section
                Button(action: onAvatarTap) {
                    EnhancedAvatarView(
                        url: profile?.picture.flatMap { URL(string: $0) },
                        size: 52,
                        fallbackText: String(profile?.name?.prefix(1) ?? "?").uppercased(),
                        showOnlineIndicator: false
                    )
                }
                .buttonStyle(PlainButtonStyle())
                .padding(.leading, 20)
                .padding(.trailing, 12)
                // Content section
                VStack(alignment: .leading, spacing: 4) {
                    HStack(alignment: .firstTextBaseline, spacing: 8) {
                        Text(profile?.displayName ?? profile?.name ?? "Unknown")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundColor(.primary)
                            .lineLimit(1)
                            .layoutPriority(1)
                        Text("")
                            .font(.system(size: 14))
                            .foregroundColor(.secondary)
                        Text(event.createdAt.formatted)
                            .font(.system(size: 13))
                            .foregroundColor(.secondary)
                        Spacer(minLength: 0)
                    }
                    RichTextInline(
                        content: event.content,
                        tags: event.tags,
                        currentUser: nil
                    )
                    .font(.system(size: 15))
                    .lineLimit(2)
                    .foregroundColor(.primary.opacity(0.9))
                // Reply info section
                if let info = replyInfo, (info.totalCount > 0 || !info.followingRepliers.isEmpty) {
                    HStack(spacing: 4) {
                        // Following repliers avatars
                        if !info.followingRepliers.isEmpty {
                            HStack(spacing: -8) {
                                ForEach(Array(info.followingRepliers.prefix(3).enumerated()), id: \.offset) { index, replierProfile in
                                    if let avatarURL = replierProfile.picture, let url = URL(string: avatarURL) {
                                        AsyncImage(url: url) { image in
                                            image
                                                .resizable()
                                                .aspectRatio(contentMode: .fill)
                                        } placeholder: {
                                            Circle()
                                                .fill(Color(.tertiarySystemFill))
                                        }
                                        .frame(width: 16, height: 16)
                                        .clipShape(Circle())
                                        .overlay(
                                            Circle()
                                                .stroke(Color(.systemBackground), lineWidth: 1)
                                        )
                                    }
                                }
                            }
                            if info.followingRepliers.count > 3 {
                                Text("+\(info.followingRepliers.count - 3)")
                                    .font(.system(size: 10))
                                    .foregroundColor(.secondary)
                            }
                        }
                        Spacer()
                        // Reply count badge
                        if info.totalCount > 0 {
                            HStack(spacing: 2) {
                                Image(systemName: "bubble.left")
                                    .font(.system(size: 10))
                                Text("\(info.totalCount)")
                                    .font(.system(size: 11))
                            }
                            .foregroundColor(.secondary)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color(.tertiarySystemFill))
                            .cornerRadius(10)
                        }
                    }
                    .padding(.top, 4)
                }
                }
                .padding(.trailing, 20)
                .padding(.vertical, 14)
            }
        }
        .contentShape(Rectangle())
        .opacity(showContent ? 1 : 0)
        .scaleEffect(showContent ? 1 : 0.95)
        .onTapGesture {
            onTap()
        }
        .scaleEffect(isPressed ? 0.97 : 1)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isPressed)
        .onLongPressGesture(
            minimumDuration: 0,
            maximumDistance: .infinity,
            pressing: { pressing in
                isPressed = pressing
            },
            perform: { }
        )
        .onAppear {
            // Animate content appearance
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8).delay(0.05)) {
                showContent = true
            }
            // Start observing profile if we don't have it yet
            if profile == nil, let ndk = ndkManager.ndk {
                profileTask = Task {
                    let profileStream = await ndk.profileManager.observe(for: event.pubkey, maxAge: TimeConstants.hour)
                    for await profileUpdate in profileStream {
                        if let profile = profileUpdate {
                            await MainActor.run {
                                self.profile = profile
                            }
                            // We only need the first valid profile for the list view
                            break
                        }
                    }
                }
            }
            // Start tracking replies
            replyTracker?.startTrackingReplies(for: event.id)
            // Check for cached reply info
            if let cachedInfo = replyTracker?.getReplyInfo(for: event.id) {
                replyInfo = cachedInfo
            }
            // Observe for updates
            if replyTracker != nil {
                pollingTask = Task { @MainActor in
                    // Poll for updates periodically
                    while !Task.isCancelled {
                        if let info = replyTracker?.getReplyInfo(for: event.id) {
                            replyInfo = info
                        }
                        try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
                    }
                }
            }
        }
        .onDisappear {
            profileTask?.cancel()
            pollingTask?.cancel()
            // Don't stop tracking immediately - let it persist for scrolling
        }
    }
}
struct ErrorBanner: View {
    let error: Error
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: "exclamationmark.triangle.fill")
                .foregroundColor(.orange)
                .font(.caption)
            Text(error.localizedDescription)
                .font(.caption)
                .lineLimit(1)
                .foregroundColor(.secondary)
            Spacer()
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(Color.orange.opacity(0.1))
        .cornerRadius(8)
    }
}
// Extension to make String identifiable for sheet
extension String: @retroactive Identifiable {
    public var id: String { self }
}
// Extension to make NDKEvent identifiable for sheet
extension NDKEvent: @retroactive Identifiable {}
// Extension for formatted timestamps
extension Timestamp {
    var formatted: String {
        let date = Date(timeIntervalSince1970: TimeInterval(self))
        let now = Date()
        let interval = now.timeIntervalSince(date)
        if interval < 60 {
            return "now"
        } else if interval < 3600 {
            let minutes = Int(interval / 60)
            return "\(minutes)m"
        } else if interval < 86400 {
            let hours = Int(interval / 3600)
            return "\(hours)h"
        } else {
            let days = Int(interval / 86400)
            return "\(days)d"
        }
    }
}
</file>

<file path="Sources/Posta/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
	</dict>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
</dict>
</plist>
</file>

<file path="Sources/Posta/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="17150" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina6_1" orientation="portrait" appearance="light"/>
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="17122"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="System colors in document resources" minToolsVersion="11.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="414" height="896"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="Posta" textAlignment="center" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="GJd-Yh-RWb">
                                <rect key="frame" x="157" y="428" width="100" height="40"/>
                                <constraints>
                                    <constraint firstAttribute="width" constant="100" id="Hjo-kX-THO"/>
                                    <constraint firstAttribute="height" constant="40" id="JgO-Kv-wcF"/>
                                </constraints>
                                <fontDescription key="fontDescription" type="system" weight="semibold" pointSize="32"/>
                                <color key="textColor" systemColor="systemBlueColor"/>
                                <nil key="highlightedColor"/>
                            </label>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                        <color key="backgroundColor" systemColor="systemBackgroundColor"/>
                        <constraints>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="QL0-4R-WVa"/>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="XVe-T9-6BN"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <systemColor name="systemBackgroundColor">
            <color white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
        </systemColor>
        <systemColor name="systemBlueColor">
            <color red="0.0" green="0.47843137254901963" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
        </systemColor>
    </resources>
</document>
</file>

<file path="Sources/Posta/NDKManager.swift">
import Foundation
import NDKSwift
import Observation
@MainActor
@Observable
class NDKManager {
    var ndk: NDK?
    var isConnected = false
    var error: Error?
    static let shared = NDKManager()
    private init() {}
    func setNDK(_ ndk: NDK) {
        self.ndk = ndk
        self.error = nil
        // Monitor connection status
        Task {
            await monitorConnectionStatus()
        }
    }
    private func monitorConnectionStatus() async {
        guard let ndk = ndk else { return }
        // Check initial connection status
        let (connected, _) = await ndk.getRelayConnectionSummary()
        isConnected = connected > 0
        // You could add a timer here to periodically check connection status
        // For now, we'll just check on initialization
    }
}
</file>

<file path="Sources/Posta/NotificationSettingsView.swift">
import SwiftUI
struct NotificationSettingsView: View {
    @AppStorage("notifications_enabled") private var notificationsEnabled = true
    @AppStorage("notify_mentions") private var notifyMentions = true
    @AppStorage("notify_replies") private var notifyReplies = true
    @AppStorage("notify_reposts") private var notifyReposts = true
    @AppStorage("notify_likes") private var notifyLikes = true
    @AppStorage("notify_follows") private var notifyFollows = true
    @AppStorage("notify_dms") private var notifyDMs = true
    @AppStorage("notification_sound") private var notificationSound = true
    @AppStorage("notification_vibrate") private var notificationVibrate = true
    var body: some View {
        List {
            // Master Toggle
            Section {
                Toggle(isOn: $notificationsEnabled) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Enable Notifications")
                        Text("Receive push notifications")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            // Notification Types
            Section {
                Toggle(isOn: $notifyMentions) {
                    Label("Mentions", systemImage: "at")
                }
                .disabled(!notificationsEnabled)
                Toggle(isOn: $notifyReplies) {
                    Label("Replies", systemImage: "bubble.left")
                }
                .disabled(!notificationsEnabled)
                Toggle(isOn: $notifyReposts) {
                    Label("Reposts", systemImage: "arrow.2.squarepath")
                }
                .disabled(!notificationsEnabled)
                Toggle(isOn: $notifyLikes) {
                    Label("Likes", systemImage: "heart")
                }
                .disabled(!notificationsEnabled)
                Toggle(isOn: $notifyFollows) {
                    Label("New Followers", systemImage: "person.badge.plus")
                }
                .disabled(!notificationsEnabled)
                Toggle(isOn: $notifyDMs) {
                    Label("Direct Messages", systemImage: "envelope")
                }
                .disabled(!notificationsEnabled)
            } header: {
                Text("Notification Types")
            }
            // Notification Behavior
            Section {
                Toggle(isOn: $notificationSound) {
                    Label("Sound", systemImage: "speaker.wave.2")
                }
                .disabled(!notificationsEnabled)
                Toggle(isOn: $notificationVibrate) {
                    Label("Vibration", systemImage: "iphone.radiowaves.left.and.right")
                }
                .disabled(!notificationsEnabled)
                HStack {
                    Label("Quiet Hours", systemImage: "moon")
                    Spacer()
                    Text("Off")
                        .foregroundColor(.secondary)
                    Image(systemName: "chevron.right")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .opacity(notificationsEnabled ? 1.0 : 0.6)
            } header: {
                Text("Behavior")
            }
            // Advanced
            Section {
                Button(action: openNotificationSettings) {
                    HStack {
                        Text("System Notification Settings")
                        Spacer()
                        Image(systemName: "arrow.up.forward.square")
                            .font(.caption)
                    }
                }
                .foregroundColor(.primary)
            } footer: {
                Text("Manage system-level notification permissions and settings")
            }
        }
        .navigationTitle("Notifications")
        .navigationBarTitleDisplayMode(.large)
    }
    private func openNotificationSettings() {
        if let url = URL(string: UIApplication.openSettingsURLString) {
            UIApplication.shared.open(url)
        }
    }
}
</file>

<file path="Sources/Posta/PostaApp.swift">
import SwiftUI
import NDKSwift
@main
struct PostaApp: App {
    @State private var authManager = NDKAuthManager.shared
    @State private var ndkManager = NDKManager.shared
    @State private var relayManager = RelayManager()
    @StateObject private var themeManager = ThemeManager()
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(authManager)
                .environment(ndkManager)
                .environment(relayManager)
                .environmentObject(themeManager)
                .preferredColorScheme(themeManager.currentTheme.colorScheme)
                .onAppear {
                    setupNDK()
                }
        }
    }
    private func setupNDK() {
        Task {
            // Get all relays (default + user added)
            let relayUrls = relayManager.getAllRelays()
            // Initialize with SQLite cache for better performance and negentropy sync support
            let ndkInstance: NDK
            do {
                // Initialize SQLite cache with debug mode for development
                let cache = try await NDKSQLiteCache(debugMode: false)
                ndkInstance = NDK(relayUrls: relayUrls, cache: cache)
                print("PostaApp - NDK initialized with SQLite cache")
            } catch {
                print("PostaApp - Failed to initialize SQLite cache: \(error). Continuing without cache.")
                ndkInstance = NDK(relayUrls: relayUrls)
            }
            // Configure client tag for Posta (NIP-89)
            ndkInstance.clientTagConfig = NDKClientTagConfig(
                name: "Posta",
                autoTag: true
            )
            // Set NDK on managers
            await MainActor.run {
                ndkManager.setNDK(ndkInstance)
                authManager.setNDK(ndkInstance)
                relayManager.setNDK(ndkInstance)
            }
            // Connect to relays
            await ndkInstance.connect()
        }
    }
}
</file>

<file path="Sources/Posta/PostaAuthView.swift">
import SwiftUI
import NDKSwift
struct PostaAuthView: View {
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @Environment(RelayManager.self) var relayManager
    @State private var loginInput: String = ""
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showingLogin = true
    @State private var loginMethod: LoginMethod = .privateKey
    enum LoginMethod: String, CaseIterable {
        case privateKey = "Private Key"
        case nip46 = "NIP-46 (Bunker)"
        var placeholder: String {
            switch self {
            case .privateKey:
                return "Enter hex or nsec..."
            case .nip46:
                return "bunker:// or npub@domain.com"
            }
        }
    }
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text("Posta")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding(.top, 50)
                Spacer()
                if showingLogin {
                    loginView
                } else {
                    registerView
                }
                Spacer()
                Button(action: {
                    showingLogin.toggle()
                }) {
                    Text(showingLogin ? "New to Posta? Create Account" : "Already have an account? Login")
                        .foregroundColor(.blue)
                }
                .padding(.bottom, 50)
            }
            .padding()
            .navigationBarHidden(true)
        }
    }
    private var loginView: some View {
        VStack(spacing: 20) {
            Text("Login")
                .font(.title2)
                .fontWeight(.semibold)
            // Login method picker
            Picker("Login Method", selection: $loginMethod) {
                ForEach(LoginMethod.allCases, id: \.self) { method in
                    Text(method.rawValue).tag(method)
                }
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding(.horizontal)
            // Input field based on login method
            TextField(loginMethod.placeholder, text: $loginInput)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .autocapitalization(.none)
                .disableAutocorrection(true)
            if let errorMessage = errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .font(.caption)
            }
            Button(action: {
                Task {
                    await performLogin()
                }
            }) {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.8)
                } else {
                    Text("Login")
                        .fontWeight(.semibold)
                }
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(Color.blue)
            .foregroundColor(.white)
            .cornerRadius(10)
            .disabled(isLoading || loginInput.isEmpty)
        }
    }
    private var registerView: some View {
        VStack(spacing: 20) {
            Text("Create Account")
                .font(.title2)
                .fontWeight(.semibold)
            Text("We'll generate a new private key for you")
                .font(.caption)
                .foregroundColor(.gray)
            if let errorMessage = errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .font(.caption)
            }
            Button(action: {
                Task {
                    await performRegister()
                }
            }) {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.8)
                } else {
                    Text("Create Account")
                        .fontWeight(.semibold)
                }
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(Color.green)
            .foregroundColor(.white)
            .cornerRadius(10)
            .disabled(isLoading)
        }
    }
    private func performLogin() async {
        isLoading = true
        errorMessage = nil
        do {
            let signer: any NDKSigner
            switch loginMethod {
            case .privateKey:
                // Check if input is nsec or hex format
                if loginInput.starts(with: "nsec1") {
                    signer = try NDKPrivateKeySigner(nsec: loginInput)
                } else {
                    // Assume hex format
                    signer = try NDKPrivateKeySigner(privateKey: loginInput)
                }
            case .nip46:
                guard let ndk = ndkManager.ndk else {
                    throw AuthError.ndkNotInitialized
                }
                // Initialize bunker signer
                if loginInput.starts(with: "bunker://") {
                    // Extract connection token from bunker URL
                    guard let connectionToken = extractConnectionToken(from: loginInput) else {
                        throw AuthError.invalidBunkerUrl
                    }
                    signer = try NDKBunkerSigner.bunker(ndk: ndk, connectionToken: connectionToken)
                } else if loginInput.contains("@") {
                    signer = try NDKBunkerSigner.nip05(ndk: ndk, nip05: loginInput)
                } else {
                    throw AuthError.invalidBunkerUrl
                }
            }
            // Create session with the signer
            _ = try await authManager.createSession(with: signer)
        } catch {
            switch loginMethod {
            case .privateKey:
                errorMessage = "Invalid private key or nsec"
            case .nip46:
                errorMessage = "Failed to connect: \(error.localizedDescription)"
            }
        }
        isLoading = false
    }
    private func performRegister() async {
        isLoading = true
        errorMessage = nil
        do {
            // Generate new private key
            let signer = try NDKPrivateKeySigner.generate()
            // Create session with the new signer
            _ = try await authManager.createSession(with: signer)
        } catch {
            errorMessage = "Failed to create account"
        }
        isLoading = false
    }
}
enum AuthError: Error {
    case invalidBunkerUrl
    case ndkNotInitialized
}
// Helper function to extract connection token from bunker URL
private func extractConnectionToken(from bunkerUrl: String) -> String? {
    // bunker://pubkey?relay=wss://relay.url&secret=token
    // We need to extract the token/secret from the URL
    guard let url = URL(string: bunkerUrl),
          let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
        return nil
    }
    // Try to find secret or token parameter
    if let secret = components.queryItems?.first(where: { $0.name == "secret" })?.value {
        return secret
    }
    // If no secret parameter, the entire path after bunker:// might be the token
    if let host = url.host, !host.isEmpty {
        return host
    }
    return nil
}
#Preview {
    PostaAuthView()
        .environment(NDKAuthManager.shared)
        .environment(NDKManager.shared)
        .environment(RelayManager())
}
</file>

<file path="Sources/Posta/PostaWelcomeView.swift">
import SwiftUI
import NDKSwift
struct PostaWelcomeView: View {
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @Environment(RelayManager.self) var relayManager
    @Environment(\.colorScheme) private var colorScheme
    // Animation states
    @State private var logoScale: CGFloat = 0.3
    @State private var logoOpacity: Double = 0
    @State private var logoRotation: Double = -180
    @State private var titleOffset: CGFloat = 50
    @State private var titleOpacity: Double = 0
    @State private var sloganOpacity: Double = 0
    @State private var sloganScale: CGFloat = 0.8
    @State private var contentOpacity: Double = 0
    @State private var glowOpacity: Double = 0
    @State private var pulseScale: CGFloat = 1
    @State private var electricityPhase: CGFloat = 0
    // Button animation states
    @State private var buttonsOffset: CGFloat = 100
    @State private var buttonsOpacity: Double = 0
    @State private var showButtons = false
    // Auth states
    @State private var loginInput: String = ""
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showingLogin = true
    @State private var loginMethod: LoginMethod = .privateKey
    // Sheet states
    @State private var showCreateAccount = false
    @State private var showImportAccount = false
    // Logo animation
    @State private var showAnimatedLogo = false
    enum LoginMethod: String, CaseIterable {
        case privateKey = "Private Key"
        case nip46 = "NIP-46 (Bunker)"
        var placeholder: String {
            switch self {
            case .privateKey:
                return "Enter hex or nsec..."
            case .nip46:
                return "bunker:// or npub@domain.com"
            }
        }
    }
    var body: some View {
        ZStack {
            // Modern animated background
            PostaBackgroundView()
            // Electric field effects
            WelcomeElectricFieldView()
                .opacity(glowOpacity * 0.5)
            VStack(spacing: 40) {
                Spacer()
                // Logo section with glow
                ZStack {
                    // Outer glow
                    Circle()
                        .fill(
                            RadialGradient(
                                gradient: Gradient(colors: [
                                    PostaColors.electricPurple.opacity(0.6),
                                    PostaColors.glowPink.opacity(0.3),
                                    Color.clear
                                ]),
                                center: .center,
                                startRadius: 20,
                                endRadius: 120
                            )
                        )
                        .frame(width: 280, height: 280)
                        .blur(radius: 30)
                        .scaleEffect(pulseScale)
                        .opacity(logoOpacity * 0.7)
                    // Logo container
                    ZStack {
                        // Background circle
                        Circle()
                            .fill(
                                LinearGradient(
                                    gradient: PostaColors.primaryGradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 160, height: 160)
                            .shadow(color: PostaColors.electricPurple.opacity(0.5), radius: 20, x: 0, y: 5)
                        // Animated Logo
                        if showAnimatedLogo {
                            AnimatedEnvelopeView(size: 100, color: .white)
                        } else {
                            PostaLogoView(size: 100, color: .white)
                        }
                    }
                    .scaleEffect(logoScale)
                    .opacity(logoOpacity)
                    .rotationEffect(.degrees(logoRotation))
                }
                // Title and slogan
                VStack(spacing: 20) {
                    Text("POSTA")
                        .font(.system(size: 56, weight: .black, design: .default))
                        .tracking(5)
                        .foregroundStyle(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.white,
                                    Color.white.opacity(0.95)
                                ]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .shadow(color: PostaColors.electricPurple.opacity(0.4), radius: 15, x: 0, y: 3)
                        .offset(y: titleOffset)
                        .opacity(titleOpacity)
                        .postaShimmer()
                    Text("ENCRYPTED NOSTR MESSAGING")
                        .font(.system(size: 14, weight: .semibold, design: .monospaced))
                        .tracking(3)
                        .foregroundColor(PostaColors.textSecondary)
                        .scaleEffect(sloganScale)
                        .opacity(sloganOpacity)
                }
                Spacer()
                // Auth buttons that slide in
                if showButtons {
                    VStack(spacing: 16) {
                        // Create new account button
                        Button(action: {
                            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                                showCreateAccount = true
                            }
                        }) {
                            HStack {
                                Image(systemName: "sparkles")
                                    .font(.system(size: 20))
                                Text("Create New Identity")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                        }
                        .buttonStyle(PostaPrimaryButtonStyle())
                        // Import existing account button
                        Button(action: {
                            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                                showImportAccount = true
                            }
                        }) {
                            HStack {
                                Image(systemName: "key.horizontal.fill")
                                    .font(.system(size: 20))
                                Text("Import Existing")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                        }
                        .buttonStyle(PostaSecondaryButtonStyle())
                        // Info text
                        HStack(spacing: 6) {
                            Image(systemName: "lock.shield.fill")
                                .font(.system(size: 12))
                            Text("Your keys, your messages")
                                .font(.system(size: 14, weight: .medium))
                        }
                        .foregroundColor(PostaColors.textTertiary)
                        .padding(.top, 12)
                    }
                    .padding(.horizontal, 32)
                    .offset(y: buttonsOffset)
                    .opacity(buttonsOpacity)
                }
                Spacer()
                    .frame(height: 80)
            }
        }
        .onAppear {
            animateWelcome()
        }
        .sheet(isPresented: $showCreateAccount) {
            CreateAccountSheet(authManager: authManager, ndkManager: ndkManager)
        }
        .sheet(isPresented: $showImportAccount) {
            ImportAccountSheet(authManager: authManager, ndkManager: ndkManager, loginMethod: $loginMethod)
        }
    }
    private func animateWelcome() {
        // Logo animation with rotation
        withAnimation(.spring(response: 1.2, dampingFraction: 0.7)) {
            logoScale = 1
            logoOpacity = 1
            logoRotation = 0
        }
        // Glow effects
        withAnimation(.easeInOut(duration: 1.5).delay(0.3)) {
            glowOpacity = 1
        }
        // Pulse animation
        withAnimation(.easeInOut(duration: 2).delay(1).repeatForever(autoreverses: true)) {
            pulseScale = 1.15
        }
        // Show animated logo after initial animation
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            withAnimation(.easeInOut(duration: 0.5)) {
                showAnimatedLogo = true
            }
        }
        // Title animation
        withAnimation(.easeOut(duration: 0.8).delay(0.8)) {
            titleOffset = 0
            titleOpacity = 1
        }
        // Slogan animation
        withAnimation(.easeOut(duration: 0.8).delay(1.2)) {
            sloganOpacity = 1
            sloganScale = 1
        }
        // Content fade in
        withAnimation(.easeInOut(duration: 0.8).delay(1.5)) {
            contentOpacity = 1
        }
        // Show and animate buttons after the main animation
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
            showButtons = true
            withAnimation(.spring(response: 0.8, dampingFraction: 0.7)) {
                buttonsOffset = 0
                buttonsOpacity = 1
            }
        }
    }
}
// MARK: - Electric Field View
struct WelcomeElectricFieldView: View {
    @State private var animationPhase: CGFloat = 0
    var body: some View {
        GeometryReader { geometry in
            ForEach(0..<5) { index in
                Path { path in
                    let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)
                    let angle = Double(index) * (2 * .pi / 5) + animationPhase
                    let endPoint = CGPoint(
                        x: center.x + Foundation.cos(angle) * geometry.size.width * 0.4,
                        y: center.y + Foundation.sin(angle) * geometry.size.height * 0.4
                    )
                    path.move(to: center)
                    // Create jagged lightning path
                    let segments = 8
                    for j in 1...segments {
                        let progress = CGFloat(j) / CGFloat(segments)
                        let baseX = center.x + (endPoint.x - center.x) * progress
                        let baseY = center.y + (endPoint.y - center.y) * progress
                        let offsetRange: CGFloat = j == segments ? 0 : 20
                        let offsetX = CGFloat.random(in: -offsetRange...offsetRange)
                        let offsetY = CGFloat.random(in: -offsetRange...offsetRange)
                        let point = j == segments ? endPoint : CGPoint(x: baseX + offsetX, y: baseY + offsetY)
                        path.addLine(to: point)
                    }
                }
                .stroke(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            PostaColors.electricPurple.opacity(0.6),
                            PostaColors.glowPink.opacity(0.3),
                            Color.clear
                        ]),
                        startPoint: .center,
                        endPoint: .bottom
                    ),
                    lineWidth: 2
                )
                .blur(radius: 3)
                .animation(
                    .linear(duration: Double.random(in: 2...4))
                    .delay(Double(index) * 0.2)
                    .repeatForever(autoreverses: false),
                    value: animationPhase
                )
            }
        }
        .onAppear {
            withAnimation(.linear(duration: 10).repeatForever(autoreverses: false)) {
                animationPhase = .pi * 2
            }
        }
    }
}
// MARK: - Create Account Sheet
struct CreateAccountSheet: View {
    let authManager: NDKAuthManager
    let ndkManager: NDKManager
    @Environment(\.dismiss) private var dismiss
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showSuccess = false
    var body: some View {
        NavigationView {
            ZStack {
                // Modern background
                PostaBackgroundView()
                VStack(spacing: 30) {
                    // Header with icon
                    VStack(spacing: 20) {
                        ZStack {
                            // Glow effect
                            Circle()
                                .fill(
                                    RadialGradient(
                                        gradient: Gradient(colors: [
                                            PostaColors.electricPurple.opacity(0.4),
                                            PostaColors.glowPink.opacity(0.2),
                                            Color.clear
                                        ]),
                                        center: .center,
                                        startRadius: 10,
                                        endRadius: 60
                                    )
                                )
                                .frame(width: 140, height: 140)
                                .blur(radius: 20)
                            Circle()
                                .fill(
                                    LinearGradient(
                                        gradient: PostaColors.primaryGradient,
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 80, height: 80)
                                .shadow(color: PostaColors.electricPurple.opacity(0.3), radius: 10, x: 0, y: 3)
                            Image(systemName: "sparkles")
                                .font(.system(size: 40))
                                .foregroundColor(.white)
                                .symbolEffect(.bounce, value: showSuccess)
                        }
                        .padding(.top, 20)
                        Text("Create New Identity")
                            .font(.system(size: 28, weight: .bold))
                            .foregroundColor(PostaColors.textPrimary)
                        Text("Generate a secure keypair for your Nostr identity")
                            .font(.system(size: 16))
                            .foregroundColor(PostaColors.textSecondary)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal)
                    }
                    Spacer()
                    // Features list
                    VStack(alignment: .leading, spacing: 20) {
                        FeatureRow(
                            icon: "lock.shield.fill",
                            text: "End-to-end encrypted messages",
                            color: PostaColors.electricPurple
                        )
                        FeatureRow(
                            icon: "key.horizontal.fill",
                            text: "Your keys stay on your device",
                            color: PostaColors.neonBlue
                        )
                        FeatureRow(
                            icon: "network",
                            text: "Decentralized communication",
                            color: PostaColors.glowPink
                        )
                    }
                    .padding(.horizontal, 32)
                    Spacer()
                    // Error message
                    if let errorMessage = errorMessage {
                        HStack(spacing: 8) {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.red)
                            Text(errorMessage)
                                .font(.system(size: 14))
                                .foregroundColor(.red)
                        }
                        .padding(.horizontal)
                        .padding(12)
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(12)
                        .padding(.horizontal, 32)
                    }
                    // Create button
                    Button(action: {
                        Task {
                            await createAccount()
                        }
                    }) {
                        if isLoading {
                            LoadingDots(dotSize: 10, color: .white)
                        } else {
                            HStack {
                                Image(systemName: "sparkles")
                                Text("Generate Identity")
                                    .fontWeight(.semibold)
                            }
                        }
                    }
                    .buttonStyle(PostaPrimaryButtonStyle(isEnabled: !isLoading))
                    .disabled(isLoading)
                    .padding(.horizontal, 32)
                    .padding(.bottom, 20)
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(PostaColors.textSecondary)
                    }
                }
            }
        }
    }
    private func createAccount() async {
        isLoading = true
        errorMessage = nil
        do {
            let signer = try NDKPrivateKeySigner.generate()
            _ = try await authManager.createSession(with: signer)
            showSuccess = true
        } catch {
            errorMessage = "Failed to create account: \(error.localizedDescription)"
        }
        isLoading = false
    }
}
// MARK: - Feature Row Component
struct FeatureRow: View {
    let icon: String
    let text: String
    let color: Color
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .frame(width: 40)
            Text(text)
                .font(.system(size: 16))
                .foregroundColor(.primary)
            Spacer()
        }
    }
}
// MARK: - Import Account Sheet
struct ImportAccountSheet: View {
    let authManager: NDKAuthManager
    let ndkManager: NDKManager
    @Binding var loginMethod: PostaWelcomeView.LoginMethod
    @Environment(\.dismiss) private var dismiss
    @State private var loginInput: String = ""
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var showingPassword = false
    @State private var showScanner = false
    var body: some View {
        NavigationView {
            ZStack {
                // Modern background
                PostaBackgroundView()
                VStack(spacing: 24) {
                    // Header with icon
                    VStack(spacing: 20) {
                        ZStack {
                            // Glow effect
                            Circle()
                                .fill(
                                    RadialGradient(
                                        gradient: Gradient(colors: [
                                            PostaColors.neonBlue.opacity(0.4),
                                            PostaColors.electricPurple.opacity(0.2),
                                            Color.clear
                                        ]),
                                        center: .center,
                                        startRadius: 10,
                                        endRadius: 60
                                    )
                                )
                                .frame(width: 140, height: 140)
                                .blur(radius: 20)
                            Circle()
                                .fill(
                                    LinearGradient(
                                        gradient: PostaColors.secondaryGradient,
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 80, height: 80)
                                .shadow(color: PostaColors.neonBlue.opacity(0.3), radius: 10, x: 0, y: 3)
                            Image(systemName: "key.horizontal.fill")
                                .font(.system(size: 40))
                                .foregroundColor(.white)
                        }
                        .padding(.top, 20)
                        Text("Import Identity")
                            .font(.system(size: 28, weight: .bold))
                            .foregroundColor(PostaColors.textPrimary)
                        Text("Enter your private key or bunker URL")
                            .font(.system(size: 16))
                            .foregroundColor(PostaColors.textSecondary)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal)
                    }
                    // Login method picker with modern styling
                    HStack(spacing: 8) {
                        ForEach(PostaWelcomeView.LoginMethod.allCases, id: \.self) { method in
                            Button(action: {
                                withAnimation(.easeInOut(duration: 0.2)) {
                                    loginMethod = method
                                }
                            }) {
                                Text(method.rawValue)
                                    .font(.system(size: 16, weight: .medium))
                                    .foregroundColor(loginMethod == method ? .white : PostaColors.textSecondary)
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 12)
                                    .background(
                                        loginMethod == method ?
                                        LinearGradient(
                                            gradient: PostaColors.primaryGradient,
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        ) : LinearGradient(
                                            gradient: Gradient(colors: [PostaColors.surfaceColor]),
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                    .cornerRadius(12)
                            }
                        }
                    }
                    .padding(.horizontal, 32)
                    // Input field with modern design
                    VStack(alignment: .leading, spacing: 8) {
                        HStack(spacing: 12) {
                            HStack {
                                if loginMethod == .privateKey && !showingPassword {
                                    SecureField(loginMethod.placeholder, text: $loginInput)
                                        .textFieldStyle(PlainTextFieldStyle())
                                        .font(.system(size: 16, design: .monospaced))
                                } else {
                                    TextField(loginMethod.placeholder, text: $loginInput)
                                        .textFieldStyle(PlainTextFieldStyle())
                                        .font(.system(size: 16, design: .monospaced))
                                        .autocapitalization(.none)
                                        .disableAutocorrection(true)
                                }
                                if loginMethod == .privateKey {
                                    Button(action: { showingPassword.toggle() }) {
                                        Image(systemName: showingPassword ? "eye.slash.fill" : "eye.fill")
                                            .font(.system(size: 16))
                                            .foregroundColor(PostaColors.textSecondary)
                                    }
                                }
                                Button(action: { showScanner = true }) {
                                    Image(systemName: "qrcode.viewfinder")
                                        .font(.system(size: 20))
                                        .foregroundColor(PostaColors.electricPurple)
                                }
                            }
                            .padding(18)
                            .background(PostaColors.surfaceColor)
                            .foregroundColor(.white)
                            .accentColor(PostaColors.electricPurple)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(PostaColors.borderColor, lineWidth: 1)
                            )
                            .clipShape(RoundedRectangle(cornerRadius: 12))
                        }
                        if loginMethod == .privateKey {
                            HStack(spacing: 6) {
                                Image(systemName: "info.circle.fill")
                                    .font(.system(size: 12))
                                Text("Accepts hex format or nsec")
                                    .font(.system(size: 13))
                            }
                            .foregroundColor(PostaColors.textTertiary)
                            .padding(.horizontal, 8)
                        }
                    }
                    .padding(.horizontal, 32)
                    // Error message
                    if let errorMessage = errorMessage {
                        HStack(spacing: 8) {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.red)
                            Text(errorMessage)
                                .font(.system(size: 14))
                                .foregroundColor(.red)
                        }
                        .padding(.horizontal)
                        .padding(12)
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(12)
                        .padding(.horizontal, 32)
                    }
                    Spacer()
                    // Import button
                    Button(action: {
                        Task {
                            await performLogin()
                        }
                    }) {
                        if isLoading {
                            LoadingDots(dotSize: 10, color: .white)
                        } else {
                            HStack {
                                Image(systemName: "arrow.down.circle.fill")
                                Text("Import Identity")
                                    .fontWeight(.semibold)
                            }
                        }
                    }
                    .buttonStyle(PostaPrimaryButtonStyle(isEnabled: !loginInput.isEmpty))
                    .disabled(isLoading || loginInput.isEmpty)
                    .padding(.horizontal, 32)
                    .padding(.bottom, 20)
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(PostaColors.textSecondary)
                    }
                }
            }
        }
        .sheet(isPresented: $showScanner) {
            QRScannerView { scannedValue in
                loginInput = scannedValue
                showScanner = false
            }
        }
    }
    private func performLogin() async {
        isLoading = true
        errorMessage = nil
        do {
            let signer: any NDKSigner
            switch loginMethod {
            case .privateKey:
                if loginInput.starts(with: "nsec1") {
                    signer = try NDKPrivateKeySigner(nsec: loginInput)
                } else {
                    signer = try NDKPrivateKeySigner(privateKey: loginInput)
                }
            case .nip46:
                guard let ndk = ndkManager.ndk else {
                    throw AuthError.ndkNotInitialized
                }
                if loginInput.starts(with: "bunker://") {
                    guard let connectionToken = extractConnectionToken(from: loginInput) else {
                        throw AuthError.invalidBunkerUrl
                    }
                    signer = try NDKBunkerSigner.bunker(ndk: ndk, connectionToken: connectionToken)
                } else if loginInput.contains("@") {
                    signer = try NDKBunkerSigner.nip05(ndk: ndk, nip05: loginInput)
                } else {
                    throw AuthError.invalidBunkerUrl
                }
            }
            _ = try await authManager.createSession(with: signer)
        } catch {
            switch loginMethod {
            case .privateKey:
                errorMessage = "Invalid private key or nsec"
            case .nip46:
                errorMessage = "Failed to connect: \(error.localizedDescription)"
            }
        }
        isLoading = false
    }
}
// MARK: - Electric Arc Shape
struct ElectricArc: Shape {
    let startPoint: CGPoint
    let endPoint: CGPoint
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let start = CGPoint(
            x: startPoint.x * rect.width,
            y: startPoint.y * rect.height
        )
        let end = CGPoint(
            x: endPoint.x * rect.width,
            y: endPoint.y * rect.height
        )
        path.move(to: start)
        // Create a jagged lightning effect
        let segments = 8
        var previousPoint = start
        for i in 1...segments {
            let progress = CGFloat(i) / CGFloat(segments)
            let baseX = start.x + (end.x - start.x) * progress
            let baseY = start.y + (end.y - start.y) * progress
            // Add random offset for electric effect
            let offsetRange: CGFloat = 20
            let offsetX = CGFloat.random(in: -offsetRange...offsetRange)
            let offsetY = CGFloat.random(in: -offsetRange...offsetRange)
            let point = CGPoint(x: baseX + offsetX, y: baseY + offsetY)
            if i == segments {
                path.addLine(to: end)
            } else {
                path.addLine(to: point)
            }
            previousPoint = point
        }
        return path
    }
}
// Helper function to extract connection token from bunker URL
private func extractConnectionToken(from bunkerUrl: String) -> String? {
    guard let url = URL(string: bunkerUrl),
          let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
        return nil
    }
    if let secret = components.queryItems?.first(where: { $0.name == "secret" })?.value {
        return secret
    }
    if let host = url.host, !host.isEmpty {
        return host
    }
    return nil
}
#Preview {
    PostaWelcomeView()
        .environment(NDKAuthManager.shared)
        .environment(NDKManager.shared)
        .environment(RelayManager())
}
</file>

<file path="Sources/Posta/PrivacySettingsView.swift">
import SwiftUI
struct PrivacySettingsView: View {
    @AppStorage("hide_sensitive_content") private var hideSensitiveContent = false
    @AppStorage("require_auth_to_view") private var requireAuthToView = false
    @AppStorage("block_strangers") private var blockStrangers = false
    @AppStorage("hide_read_receipts") private var hideReadReceipts = false
    @AppStorage("disable_analytics") private var disableAnalytics = false
    @AppStorage("clear_cache_on_exit") private var clearCacheOnExit = false
    var body: some View {
        List {
            // Content Privacy
            Section {
                Toggle(isOn: $hideSensitiveContent) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Hide Sensitive Content")
                        Text("Blur potentially sensitive media")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                Toggle(isOn: $requireAuthToView) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Require Authentication")
                        Text("Use biometrics to open the app")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            } header: {
                Text("Content")
            }
            // Communication Privacy
            Section {
                Toggle(isOn: $blockStrangers) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Block Messages from Strangers")
                        Text("Only receive messages from people you follow")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                Toggle(isOn: $hideReadReceipts) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Hide Read Receipts")
                        Text("Don't send read confirmations")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            } header: {
                Text("Communication")
            }
            // Data Privacy
            Section {
                Toggle(isOn: $disableAnalytics) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Disable Analytics")
                        Text("Don't share usage data")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                Toggle(isOn: $clearCacheOnExit) {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Clear Cache on Exit")
                        Text("Remove temporary data when closing app")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                Button(action: clearAllData) {
                    HStack {
                        Image(systemName: "trash")
                            .foregroundColor(.red)
                        Text("Clear All App Data")
                            .foregroundColor(.red)
                    }
                }
            } header: {
                Text("Data")
            }
            // Blocked Users
            Section {
                NavigationLink(destination: BlockedUsersView()) {
                    HStack {
                        Text("Blocked Users")
                        Spacer()
                        Text("0")
                            .foregroundColor(.secondary)
                    }
                }
                NavigationLink(destination: MutedWordsView()) {
                    HStack {
                        Text("Muted Words")
                        Spacer()
                        Text("0")
                            .foregroundColor(.secondary)
                    }
                }
            } header: {
                Text("Filters")
            }
        }
        .navigationTitle("Privacy & Security")
        .navigationBarTitleDisplayMode(.large)
    }
    private func clearAllData() {
        // Implementation for clearing app data
    }
}
struct BlockedUsersView: View {
    var body: some View {
        List {
            Text("No blocked users")
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 40)
        }
        .navigationTitle("Blocked Users")
    }
}
struct MutedWordsView: View {
    var body: some View {
        List {
            Text("No muted words")
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 40)
        }
        .navigationTitle("Muted Words")
    }
}
</file>

<file path="Sources/Posta/ProfileView.swift">
import SwiftUI
import NDKSwift
struct ProfileView: View {
    let pubkey: String?
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @Environment(\.dismiss) private var dismiss
    @State private var profile: NDKUserProfile?
    @State private var notes: [NDKEvent] = []
    @State private var isLoadingProfile = false
    @State private var isLoadingNotes = false
    @State private var profileError: Error?
    @State private var notesError: Error?
    @State private var followCount: Int?
    @State private var followerCount: Int?
    @State private var isFollowing = false
    @State private var showingQRCode = false
    @State private var selectedTab = 0
    @State private var showContent = false
    @State private var showingLogoutConfirmation = false
    @State private var isLoggingOut = false
    private var displayPubkey: String {
        pubkey ?? authManager.activeSession?.pubkey ?? ""
    }
    private var isOwnProfile: Bool {
        displayPubkey == authManager.activeSession?.pubkey
    }
    init(pubkey: String?) {
        self.pubkey = pubkey
    }
    var body: some View {
        NavigationView {
            ZStack {
                // Animated gradient background
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(.systemBackground),
                        Color.purple.opacity(0.03),
                        Color(.systemBackground)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                ScrollView {
                        VStack(spacing: 0) {
                            // Header with banner and avatar
                            profileHeaderView
                            // Profile info section
                            profileInfoView
                                .padding(.horizontal, 20)
                                .padding(.top, -30)
                            // Stats and action buttons
                            statsAndActionsView
                                .padding(.horizontal, 20)
                                .padding(.top, 20)
                            // Tab selector
                            tabSelector
                                .padding(.top, 24)
                            // Content based on selected tab
                            switch selectedTab {
                            case 0:
                                notesSection
                                    .padding(.top, 8)
                            case 1:
                                repliesSection
                                    .padding(.top, 8)
                            case 2:
                                mediaSection
                                    .padding(.top, 8)
                            default:
                                EmptyView()
                            }
                        }
                    }
                    .ignoresSafeArea(edges: .top)
                // Error overlay
                if let error = profileError ?? notesError {
                    VStack {
                        Spacer()
                        ErrorBanner(error: error)
                            .padding()
                    }
                }
            }
            .navigationBarHidden(true)
            .overlay(alignment: .topTrailing) {
                closeButton
            }
        }
        .task {
            await loadProfile()
            await loadNotes()
            await loadStats()
        }
        .sheet(isPresented: $showingQRCode) {
            if let pubkey = displayPubkey.isEmpty ? nil : displayPubkey {
                QRCodeView(pubkey: pubkey, profile: profile)
            }
        }
        .alert("Log Out", isPresented: $showingLogoutConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Log Out", role: .destructive) {
                Task {
                    await performLogout()
                }
            }
        } message: {
            Text("Are you sure you want to log out? This will remove your session from this device.")
        }
    }
    private var profileHeaderView: some View {
        ZStack(alignment: .bottom) {
            // Banner with parallax effect
            GeometryReader { geometry in
                if let banner = profile?.banner, let url = URL(string: banner) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    } placeholder: {
                        shimmeringBannerPlaceholder
                    }
                    .frame(width: geometry.size.width, height: 250)
                    .clipped()
                    .overlay(bannerOverlay)
                } else {
                    defaultBanner
                        .frame(height: 250)
                }
            }
            .frame(height: 200)
            .clipped()
            // Avatar with animation
            HStack {
                avatarView
                    .padding(.leading, 20)
                    .padding(.bottom, -50)
                    .scaleEffect(showContent ? 1 : 0.8)
                    .opacity(showContent ? 1 : 0)
                Spacer()
            }
        }
        .frame(height: 200)
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.2)) {
                showContent = true
            }
        }
    }
    private var shimmeringBannerPlaceholder: some View {
        Rectangle()
            .fill(Color(.systemGray5))
            .postaShimmer()
    }
    private var defaultBanner: some View {
        ZStack {
            LinearGradient(
                gradient: Gradient(colors: [
                    Color.purple.opacity(0.3),
                    Color.purple.opacity(0.1)
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated pattern
            WaveShape(phase: 0)
                .fill(Color.purple.opacity(0.1))
                .offset(y: 50)
        }
    }
    private var bannerOverlay: some View {
        LinearGradient(
            colors: [
                Color.black.opacity(0),
                Color.black.opacity(0.2),
                Color.black.opacity(0.4)
            ],
            startPoint: .top,
            endPoint: .bottom
        )
    }
    private var avatarView: some View {
        EnhancedAvatarView(
            url: profile?.picture.flatMap { URL(string: $0) },
            size: 120,
            fallbackText: avatarInitial,
            showOnlineIndicator: false
        )
        .overlay(
            Circle()
                .stroke(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.purple.opacity(0.5),
                            Color.purple.opacity(0.2)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 3
                )
        )
        .shadow(color: Color.purple.opacity(0.2), radius: 12, x: 0, y: 4)
    }
    private var avatarInitial: String {
        let name = profile?.displayName ?? profile?.name ?? "?"
        return String(name.prefix(1)).uppercased()
    }
    private var profileInfoView: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(profile?.displayName ?? profile?.name ?? "Unknown")
                        .font(.title)
                        .fontWeight(.bold)
                    if let nip05 = profile?.nip05 {
                        Label(nip05, systemImage: "checkmark.seal.fill")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                Spacer()
            }
            .padding(.top, 60)
            if let about = profile?.about, !about.isEmpty {
                Text(about)
                    .font(.body)
                    .foregroundColor(.primary.opacity(0.9))
                    .fixedSize(horizontal: false, vertical: true)
                    .padding(.top, 4)
            }
        }
    }
    private var statsAndActionsView: some View {
        VStack(spacing: 16) {
            HStack(spacing: 40) {
                StatView(count: notes.count, label: "Posts")
                StatView(count: followCount ?? 0, label: "Following")
                StatView(count: followerCount ?? 0, label: "Followers")
                Spacer()
            }
            HStack(spacing: 12) {
                if displayPubkey != authManager.activeSession?.pubkey {
                    Button(action: {
                        HapticFeedback.notification(.success)
                        // Toggle follow
                    }) {
                        HStack {
                            Image(systemName: isFollowing ? "person.badge.minus" : "person.badge.plus")
                            Text(isFollowing ? "Unfollow" : "Follow")
                        }
                    }
                    .buttonStyle(PostaPrimaryButtonStyle(isEnabled: !isFollowing))
                } else {
                    // Show settings and logout for own profile
                    NavigationLink(destination: SettingsView()) {
                        HStack {
                            Image(systemName: "gearshape")
                            Text("Settings")
                        }
                    }
                    .buttonStyle(PostaPrimaryButtonStyle(isEnabled: true))
                    Button(action: {
                        showingLogoutConfirmation = true
                        HapticFeedback.impact(.light)
                    }) {
                        HStack {
                            if isLoggingOut {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(0.8)
                                    .tint(.white)
                            } else {
                                Image(systemName: "rectangle.portrait.and.arrow.right")
                            }
                            Text(isLoggingOut ? "Logging out..." : "Log Out")
                        }
                    }
                    .buttonStyle(PlainButtonStyle())
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 56)
                    .background(
                        LinearGradient(
                            gradient: Gradient(colors: [Color.red, Color.red.opacity(0.8)]),
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                    .shadow(
                        color: Color.red.opacity(0.3),
                        radius: 10,
                        x: 0,
                        y: 4
                    )
                    .disabled(isLoggingOut)
                }
                Button(action: {
                    showingQRCode = true
                    HapticFeedback.impact(.light)
                }) {
                    Image(systemName: "qrcode")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.primary)
                        .frame(width: 44, height: 44)
                        .background(Color(.tertiarySystemFill))
                        .cornerRadius(10)
                }
                .buttonStyle(HapticButtonStyle())
            }
        }
    }
    private var notesSection: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack {
                Text("Posts")
                    .font(.title2)
                    .fontWeight(.bold)
                    .padding(.horizontal, 20)
                Spacer()
                if isLoadingNotes {
                    ProgressView()
                        .scaleEffect(0.8)
                        .padding(.trailing, 20)
                }
            }
            .padding(.bottom, 16)
            if notes.isEmpty && !isLoadingNotes {
                VStack(spacing: 12) {
                    Image(systemName: "note.text")
                        .font(.largeTitle)
                        .foregroundColor(.secondary)
                    Text("No posts yet")
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
            } else {
                LazyVStack(spacing: 0) {
                    ForEach(notes, id: \.id) { note in
                        NoteRowView(note: note, profile: profile)
                        if note.id != notes.last?.id {
                            Divider()
                                .padding(.leading, 20)
                        }
                    }
                }
            }
        }
    }
    private var closeButton: some View {
        Button(action: {
            HapticFeedback.impact(.light)
            dismiss()
        }) {
            ZStack {
                VisualEffectBlur(blurStyle: .systemThinMaterial)
                    .frame(width: 36, height: 36)
                    .clipShape(Circle())
                Image(systemName: "xmark")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.primary)
            }
        }
        .padding()
    }
    private var tabSelector: some View {
        HStack(spacing: 0) {
            TabButton(title: "Posts", icon: "note.text", isSelected: selectedTab == 0) {
                selectedTab = 0
                HapticFeedback.selection()
            }
            TabButton(title: "Replies", icon: "bubble.left", isSelected: selectedTab == 1) {
                selectedTab = 1
                HapticFeedback.selection()
            }
            TabButton(title: "Media", icon: "photo", isSelected: selectedTab == 2) {
                selectedTab = 2
                HapticFeedback.selection()
            }
        }
        .padding(.horizontal, 20)
    }
    private var repliesSection: some View {
        VStack {
            Text("Replies")
                .font(.title3)
                .padding()
            // TODO: Implement replies
        }
    }
    private var mediaSection: some View {
        VStack {
            Text("Media")
                .font(.title3)
                .padding()
            // TODO: Implement media grid
        }
    }
    private func loadStats() async {
        guard let ndk = ndkManager.ndk else { return }
        // Load follow count
        let followFilter = NDKFilter(
            authors: [displayPubkey],
            kinds: [EventKind.contacts],
            limit: 1
        )
        let dataSource = ndk.observe(filter: followFilter, maxAge: 3600)
        for await event in dataSource.events {
            let follows = event.tags.filter { $0.count >= 1 && $0[0] == "p" }.count
            await MainActor.run {
                followCount = follows
            }
            break // Only need the first/latest contact list
        }
        // Note: Follower count would require scanning all contact lists
        // which is expensive. This is typically done with a specialized relay.
    }
    private func loadProfile() async {
        guard let ndk = ndkManager.ndk else { return }
        isLoadingProfile = true
        profileError = nil
        let filter = NDKFilter(
            authors: [displayPubkey],
            kinds: [0],
            limit: 1
        )
        let dataSource = ndk.observe(filter: filter, maxAge: 3600) // Cache for 1 hour
        // Wait for first event
        for await event in dataSource.events {
            if let profileData = event.content.data(using: .utf8) {
                profile = JSONCoding.safeDecode(NDKUserProfile.self, from: profileData)
                isLoadingProfile = false
                break // Only need the first/latest profile
            }
        }
        isLoadingProfile = false
    }
    private func loadNotes() async {
        guard let ndk = ndkManager.ndk else { return }
        isLoadingNotes = true
        notesError = nil
        let filter = NDKFilter(
            authors: [displayPubkey],
            kinds: [EventKind.textNote],
            limit: 50
        )
        let dataSource = ndk.observe(filter: filter, maxAge: 300) // Cache for 5 minutes
        // Collect initial batch of notes
        var collectedNotes: [NDKEvent] = []
        for await event in dataSource.events {
            collectedNotes.append(event)
            // Wait for a moment to collect initial batch
            if collectedNotes.count >= 20 {
                break
            }
        }
        notes = collectedNotes.sorted(by: { $0.createdAt > $1.createdAt })
        isLoadingNotes = false
    }
    private func performLogout() async {
        isLoggingOut = true
        // Clear cache if available
        if let cache = ndkManager.ndk?.cache {
            try? await cache.clear()
        }
        // CRITICAL: Delete all sessions from keychain to prevent resurrection on app restart
        // This follows section 2.1 of NDKSWIFT-EXPERT-PROMPT.md
        for session in authManager.availableSessions {
            try? await authManager.deleteSession(session)
        }
        // Clear memory state
        await MainActor.run {
            authManager.logout()
            isLoggingOut = false
            dismiss()
        }
    }
}
struct StatView: View {
    let count: Int
    let label: String
    var body: some View {
        VStack(spacing: 4) {
            Text("\(count)")
                .font(.system(size: 20, weight: .semibold))
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}
struct NoteRowView: View {
    let note: NDKEvent
    let profile: NDKUserProfile?
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            // Small avatar
            if let picture = profile?.picture, let url = URL(string: picture) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle()
                        .fill(Color(.tertiarySystemFill))
                }
                .frame(width: 40, height: 40)
                .clipShape(Circle())
            } else {
                Circle()
                    .fill(Color(.tertiarySystemFill))
                    .frame(width: 40, height: 40)
            }
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(profile?.displayName ?? profile?.name ?? "Unknown")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    Spacer()
                    Text(note.createdAt.formatted)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Text(note.content)
                    .font(.body)
                    .foregroundColor(.primary.opacity(0.9))
                    .fixedSize(horizontal: false, vertical: true)
            }
            Spacer(minLength: 0)
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 12)
    }
}
struct QRCodeView: View {
    let pubkey: String
    let profile: NDKUserProfile?
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text(profile?.displayName ?? profile?.name ?? "User")
                    .font(.title2)
                    .fontWeight(.semibold)
                // QR Code would go here
                Image(systemName: "qrcode")
                    .font(.system(size: 200))
                    .foregroundColor(.primary)
                    .padding(40)
                    .background(Color(.secondarySystemBackground))
                    .cornerRadius(20)
                Text("npub: \(String(pubkey.prefix(16)))...")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .monospaced()
            }
            .padding()
            .navigationTitle("QR Code")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/RelayManager.swift">
import Foundation
import NDKSwift
import Observation
@MainActor
@Observable
class RelayManager {
    private(set) var ndk: NDK?
    var userAddedRelays: Set<String> = []
    private let defaultRelays = [
        RelayConstants.primal,
        RelayConstants.damus,
        RelayConstants.nostrBand,
        RelayConstants.nosLol
    ]
    private let userRelaysKey = "user_added_relays"
    init() {
        loadUserRelays()
    }
    func setNDK(_ ndk: NDK) {
        self.ndk = ndk
    }
    func getAllRelays() -> [String] {
        var relays = Set(defaultRelays)
        relays.formUnion(userAddedRelays)
        return Array(relays)
    }
    func addUserRelay(_ url: String) {
        let normalizedUrl = normalizeRelayUrl(url)
        userAddedRelays.insert(normalizedUrl)
        saveUserRelays()
        // Add to NDK if initialized
        if let ndk = ndk {
            Task {
                await ndk.addRelayAndConnect(normalizedUrl)
            }
        }
    }
    func removeUserRelay(_ url: String) {
        userAddedRelays.remove(url)
        saveUserRelays()
        // Remove from NDK if initialized and not a default relay
        if let ndk = ndk, !defaultRelays.contains(url) {
            Task {
                let allRelays = await ndk.relays
                if let relay = allRelays.first(where: { $0.url == url }) {
                    await relay.disconnect()
                    // Note: NDK doesn't have a removeRelay method, so we just disconnect
                }
            }
        }
    }
    func resetToDefaults() {
        userAddedRelays.removeAll()
        saveUserRelays()
        // Reconnect with only default relays
        if let ndk = ndk {
            Task {
                // Disconnect all non-default relays
                let allRelays = await ndk.relays
                for relay in allRelays where !defaultRelays.contains(relay.url) {
                    await relay.disconnect()
                }
            }
        }
    }
    private func normalizeRelayUrl(_ url: String) -> String {
        var normalized = url.trimmingCharacters(in: .whitespacesAndNewlines)
        if !normalized.hasPrefix("wss://") && !normalized.hasPrefix("ws://") {
            normalized = "wss://\(normalized)"
        }
        // Note: NDK handles URL normalization internally, including trailing slashes
        return normalized
    }
    private func loadUserRelays() {
        if let savedRelays = UserDefaults.standard.array(forKey: userRelaysKey) as? [String] {
            userAddedRelays = Set(savedRelays)
        }
    }
    private func saveUserRelays() {
        UserDefaults.standard.set(Array(userAddedRelays), forKey: userRelaysKey)
    }
}
</file>

<file path="Sources/Posta/RelaySettingsView.swift">
import SwiftUI
import NDKSwift
struct RelaySettingsView: View {
    @Environment(RelayManager.self) var relayManager
    @Environment(NDKManager.self) var ndkManager
    @State private var showingAddRelay = false
    @State private var newRelayUrl = ""
    @State private var showingResetConfirmation = false
    var body: some View {
        List {
            if let ndk = ndkManager.ndk {
                RelayListContent(ndk: ndk, relayManager: relayManager)
            } else {
                VStack(spacing: 16) {
                    Image(systemName: "network.slash")
                        .font(.system(size: 60))
                        .foregroundStyle(.secondary)
                    Text("NDK not initialized")
                        .font(.headline)
                        .foregroundStyle(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
                .listRowBackground(Color.clear)
            }
            // Actions Section
            Section {
                Button(action: { showingAddRelay = true }) {
                    HStack {
                        Image(systemName: "plus.circle.fill")
                            .foregroundColor(.blue)
                        Text("Add Relay")
                    }
                }
                Button(action: { showingResetConfirmation = true }) {
                    HStack {
                        Image(systemName: "arrow.counterclockwise")
                            .foregroundColor(.orange)
                        Text("Reset to Defaults")
                    }
                }
            }
        }
        .navigationTitle("Relays")
        .navigationBarTitleDisplayMode(.large)
        .sheet(isPresented: $showingAddRelay) {
            AddRelayView()
        }
        .confirmationDialog(
            "Reset Relays",
            isPresented: $showingResetConfirmation,
            titleVisibility: .visible
        ) {
            Button("Reset", role: .destructive) {
                relayManager.resetToDefaults()
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("This will remove all custom relays and restore the default relay list.")
        }
    }
}
// Separate view for relay list content that observes NDK relays
struct RelayListContent: View {
    let ndk: NDK
    let relayManager: RelayManager
    @StateObject private var relayCollection: NDKRelayCollection
    init(ndk: NDK, relayManager: RelayManager) {
        self.ndk = ndk
        self.relayManager = relayManager
        self._relayCollection = StateObject(wrappedValue: ndk.createRelayCollection())
    }
    var body: some View {
        Group {
            // Stats Section
            Section {
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("\(relayCollection.connectedCount) of \(relayCollection.totalCount) connected")
                            .font(.headline)
                        Text("Active relays")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    Spacer()
                    Image(systemName: "antenna.radiowaves.left.and.right")
                        .font(.title2)
                        .foregroundColor(.blue)
                }
                .padding()
                .listRowInsets(EdgeInsets())
                .listRowBackground(Color.clear)
            }
            // Relay List
            if relayCollection.relays.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "network.slash")
                        .font(.system(size: 60))
                        .foregroundStyle(.secondary)
                    Text("No relays configured")
                        .font(.headline)
                        .foregroundStyle(.secondary)
                    Text("Add relays to connect to the Nostr network")
                        .font(.subheadline)
                        .foregroundStyle(.tertiary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
                .listRowBackground(Color.clear)
            } else {
                Section("Relays") {
                    ForEach(relayCollection.relays) { relayInfo in
                        RelayRow(relayInfo: relayInfo, ndk: ndk, relayManager: relayManager)
                    }
                }
            }
        }
    }
}
struct RelayRow: View {
    let relayInfo: NDKRelayCollection.RelayInfo
    let ndk: NDK
    let relayManager: RelayManager
    @State private var showDetails = false
    @State private var relay: NDKRelay?
    @State private var relayState: NDKRelay.State?
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(relayInfo.url)
                    .font(.system(.body, design: .monospaced))
                    .lineLimit(1)
                HStack(spacing: 4) {
                    Circle()
                        .fill(relayInfo.isConnected ? Color.green : Color.gray)
                        .frame(width: 8, height: 8)
                    Text(relayInfo.isConnected ? "Connected" : "Disconnected")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    if let state = relayState,
                       let name = state.info?.name {
                        Text(" \(name)")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
            }
            Spacer()
            Image(systemName: "chevron.right")
                .foregroundStyle(.tertiary)
        }
        .contentShape(Rectangle())
        .onTapGesture {
            showDetails = true
        }
        .swipeActions(edge: .trailing, allowsFullSwipe: false) {
            if relayManager.userAddedRelays.contains(relayInfo.url) {
                Button(role: .destructive, action: {
                    relayManager.removeUserRelay(relayInfo.url)
                }) {
                    Label("Delete", systemImage: "trash")
                }
            }
        }
        .sheet(isPresented: $showDetails) {
            if let relay = relay, let state = relayState {
                RelayDetailView(relay: relay, initialState: state, relayManager: relayManager)
            }
        }
        .task {
            // Get the actual relay and its current state
            await loadRelay()
        }
    }
    private func loadRelay() async {
        let allRelays = await ndk.relays
        if let foundRelay = allRelays.first(where: { $0.url == relayInfo.url }) {
            self.relay = foundRelay
            // Get initial state
            for await state in foundRelay.stateStream {
                await MainActor.run {
                    self.relayState = state
                }
                // Only need the first state for display
                break
            }
        }
    }
}
// MARK: - Relay Detail View
struct RelayDetailView: View {
    let relay: NDKRelay
    let initialState: NDKRelay.State
    let relayManager: RelayManager
    @Environment(\.dismiss) private var dismiss
    @State private var currentState: NDKRelay.State
    @State private var showDisconnectAlert = false
    @State private var observationTask: Task<Void, Never>?
    init(relay: NDKRelay, initialState: NDKRelay.State, relayManager: RelayManager) {
        self.relay = relay
        self.initialState = initialState
        self.relayManager = relayManager
        self._currentState = State(initialValue: initialState)
    }
    var body: some View {
        NavigationStack {
            List {
                // Connection Status
                Section("Connection") {
                    LabeledContent("Status", value: statusText)
                    if let connectedAt = currentState.stats.connectedAt {
                        LabeledContent("Connected Since") {
                            Text(connectedAt, style: .relative)
                        }
                    }
                    if let lastMessage = currentState.stats.lastMessageAt {
                        LabeledContent("Last Message") {
                            Text(lastMessage, style: .relative)
                        }
                    }
                    LabeledContent("Connection Attempts", value: "\(currentState.stats.connectionAttempts)")
                    LabeledContent("Successful Connections", value: "\(currentState.stats.successfulConnections)")
                }
                // Traffic Statistics
                Section("Traffic") {
                    LabeledContent("Messages Sent", value: "\(currentState.stats.messagesSent)")
                    LabeledContent("Messages Received", value: "\(currentState.stats.messagesReceived)")
                    LabeledContent("Bytes Sent", value: formatBytes(currentState.stats.bytesSent))
                    LabeledContent("Bytes Received", value: formatBytes(currentState.stats.bytesReceived))
                    if let latency = currentState.stats.latency {
                        LabeledContent("Latency", value: String(format: "%.0f ms", latency * 1000))
                    }
                }
                // Relay Information (NIP-11)
                if let info = currentState.info {
                    Section {
                        if let name = info.name {
                            LabeledContent("Name", value: name)
                        }
                        if let description = info.description {
                            LabeledContent("Description", value: description)
                        }
                        if let software = info.software {
                            LabeledContent("Software", value: software)
                        }
                        if let version = info.version {
                            LabeledContent("Version", value: version)
                        }
                        if let contact = info.contact {
                            LabeledContent("Contact", value: contact)
                        }
                    } header: {
                        Text("Relay Information")
                    }
                    if let supportedNips = info.supportedNips, !supportedNips.isEmpty {
                        Section {
                            Text(supportedNips.map { String($0) }.joined(separator: ", "))
                                .font(.system(.body, design: .monospaced))
                        } header: {
                            Text("Supported NIPs")
                        }
                    }
                }
                // Actions
                Section {
                    if case .connected = currentState.connectionState {
                        Button(role: .destructive, action: { showDisconnectAlert = true }) {
                            Label("Disconnect", systemImage: "xmark.circle")
                                .foregroundColor(.red)
                        }
                    } else {
                        Button(action: reconnect) {
                            Label("Connect", systemImage: "arrow.clockwise")
                        }
                    }
                    // Allow removing user-added relays
                    if relayManager.userAddedRelays.contains(relay.url) {
                        Button(role: .destructive, action: removeRelay) {
                            Label("Remove from App", systemImage: "trash")
                                .foregroundColor(.red)
                        }
                    }
                }
            }
            .navigationTitle(relay.url)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                }
            }
            .alert("Disconnect Relay?", isPresented: $showDisconnectAlert) {
                Button("Cancel", role: .cancel) { }
                Button("Disconnect", role: .destructive) {
                    Task {
                        await relay.disconnect()
                        dismiss()
                    }
                }
            } message: {
                Text("Are you sure you want to disconnect from this relay?")
            }
            .onAppear {
                startObserving()
            }
            .onDisappear {
                stopObserving()
            }
        }
    }
    private var statusText: String {
        switch currentState.connectionState {
        case .connected:
            return "Connected"
        case .connecting:
            return "Connecting..."
        case .disconnected:
            return "Disconnected"
        case .disconnecting:
            return "Disconnecting..."
        case .failed(let error):
            return "Failed: \(error)"
        }
    }
    private func reconnect() {
        Task {
            do {
                try await relay.connect()
                dismiss()
            } catch {
                print("Failed to reconnect: \(error)")
            }
        }
    }
    private func removeRelay() {
        Task {
            // Remove relay from manager
            relayManager.removeUserRelay(relay.url)
            await MainActor.run {
                dismiss()
            }
        }
    }
    private func formatBytes(_ bytes: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .binary
        return formatter.string(fromByteCount: Int64(bytes))
    }
    private func startObserving() {
        observationTask = Task {
            for await state in relay.stateStream {
                await MainActor.run {
                    self.currentState = state
                }
            }
        }
    }
    private func stopObserving() {
        observationTask?.cancel()
        observationTask = nil
    }
}
struct AddRelayView: View {
    @Environment(RelayManager.self) var relayManager
    @Environment(NDKManager.self) var ndkManager
    @Environment(\.dismiss) var dismiss
    @State private var relayUrl = ""
    @State private var showingError = false
    @State private var errorMessage = ""
    @State private var isAdding = false
    let suggestedRelays = [
        RelayConstants.damus,
        RelayConstants.nostrBand,
        "wss://relayable.org", 
        RelayConstants.nosLol,
        RelayConstants.snortSocial,
        RelayConstants.nostrWine
    ]
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Input Section
                VStack(alignment: .leading, spacing: 8) {
                    Text("Relay URL")
                        .font(.headline)
                    TextField("wss://relay.example.com", text: $relayUrl)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .keyboardType(.URL)
                }
                .padding(.horizontal)
                .padding(.top)
                // Suggested Relays
                VStack(alignment: .leading, spacing: 12) {
                    Text("Suggested Relays")
                        .font(.headline)
                        .padding(.horizontal)
                    ScrollView {
                        VStack(spacing: 8) {
                            ForEach(suggestedRelays, id: \.self) { relay in
                                // Check both with and without trailing slash
                                if !relayManager.userAddedRelays.contains(relay) && 
                                   !relayManager.userAddedRelays.contains(relay + "/") &&
                                   !relayManager.userAddedRelays.contains(String(relay.dropLast())) {
                                    Button(action: { 
                                        relayUrl = relay
                                        addRelay(relay) 
                                    }) {
                                        HStack {
                                            Text(relay)
                                                .font(.caption)
                                                .foregroundColor(.primary)
                                            Spacer()
                                            Image(systemName: "plus.circle")
                                                .foregroundColor(.blue)
                                        }
                                        .padding(.horizontal)
                                        .padding(.vertical, 8)
                                        .background(Color.gray.opacity(0.1))
                                        .cornerRadius(8)
                                    }
                                    .disabled(isAdding)
                                }
                            }
                        }
                        .padding(.horizontal)
                    }
                }
                Spacer()
            }
            .navigationTitle("Add Relay")
            .navigationBarItems(
                leading: Button("Cancel") { dismiss() },
                trailing: Button("Add") { 
                    addRelay(relayUrl) 
                }
                .disabled(relayUrl.isEmpty || isAdding)
            )
            .alert("Error", isPresented: $showingError) {
                Button("OK") {}
            } message: {
                Text(errorMessage)
            }
        }
    }
    private func addRelay(_ url: String) {
        let trimmedUrl = url.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedUrl.isEmpty else {
            errorMessage = "Please enter a relay URL"
            showingError = true
            return
        }
        guard trimmedUrl.hasPrefix("wss://") || trimmedUrl.hasPrefix("ws://") else {
            errorMessage = "Relay URL must start with wss:// or ws://"
            showingError = true
            return
        }
        isAdding = true
        Task {
            do {
                // Add relay to NDK and connect to it
                guard let ndk = ndkManager.ndk else {
                    throw NSError(domain: "PostaApp", code: 0, userInfo: [NSLocalizedDescriptionKey: "NDK not initialized"])
                }
                guard let _ = await ndk.addRelayAndConnect(trimmedUrl) else {
                    throw NSError(domain: "PostaApp", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to add relay"])
                }
                // Persist the relay for future app launches
                relayManager.addUserRelay(trimmedUrl)
                await MainActor.run {
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showingError = true
                    isAdding = false
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/ReplyTracker.swift">
import Foundation
import NDKSwift
import Observation
/// Manages reply tracking for all events in a performant way
@MainActor
@Observable
class ReplyTracker {
    struct ReplyInfo {
        let totalCount: Int
        let followingRepliers: [NDKUserProfile]
        let lastUpdated: Date
    }
    private var replyCache: [String: ReplyInfo] = [:]
    private var activeSubscriptions: [String: Task<Void, Never>] = [:]
    private weak var ndk: NDK?
    private var followingSet: Set<String> = []
    init(ndk: NDK, following: Set<String>) {
        self.ndk = ndk
        self.followingSet = following
    }
    func updateFollowing(_ following: Set<String>) {
        self.followingSet = following
    }
    func getReplyInfo(for eventId: String) -> ReplyInfo? {
        return replyCache[eventId]
    }
    func startTrackingReplies(for eventId: String) {
        // Don't start duplicate subscriptions
        guard activeSubscriptions[eventId] == nil,
              let ndk = ndk else { return }
        let task = Task { [weak self] in
            guard let self = self else { return }
            // Create filter for replies
            let replyFilter = NDKFilter(
                kinds: [EventKind.textNote],
                tags: ["e": Set([eventId])]
            )
            let dataSource = ndk.observe(filter: replyFilter, maxAge: 300) // 5 min cache
            var replyCount = 0
            var seenRepliers = Set<String>()
            var followingReplierProfiles: [NDKUserProfile] = []
            for await reply in dataSource.events {
                // Check if this is a direct reply (last "e" tag)
                let isDirectReply = reply.tags
                    .filter { $0.count >= 2 && $0[0] == "e" }
                    .last?.contains(eventId) ?? false
                if isDirectReply {
                    replyCount += 1
                    // Check if replier is someone we follow
                    if self.followingSet.contains(reply.pubkey),
                       !seenRepliers.contains(reply.pubkey) {
                        seenRepliers.insert(reply.pubkey)
                        // Fetch profile (with caching via profileManager)
                        let profileStream = await ndk.profileManager.observe(for: reply.pubkey, maxAge: TimeConstants.hour)
                        for await profile in profileStream {
                            if let profile = profile {
                                followingReplierProfiles.append(profile)
                            }
                            break // Only need the first profile
                        }
                    }
                    // Update cache
                    let info = ReplyInfo(
                        totalCount: replyCount,
                        followingRepliers: followingReplierProfiles.sorted { 
                            ($0.name ?? "") < ($1.name ?? "") 
                        },
                        lastUpdated: Date()
                    )
                    await MainActor.run {
                        self.replyCache[eventId] = info
                    }
                }
            }
        }
        activeSubscriptions[eventId] = task
    }
    func stopTrackingReplies(for eventId: String) {
        activeSubscriptions[eventId]?.cancel()
        activeSubscriptions[eventId] = nil
    }
    func stopAllTracking() {
        for task in activeSubscriptions.values {
            task.cancel()
        }
        activeSubscriptions.removeAll()
    }
}
</file>

<file path="Sources/Posta/SettingsView.swift">
import SwiftUI
import NDKSwift
struct SettingsView: View {
    @Environment(NDKAuthManager.self) var authManager
    @Environment(NDKManager.self) var ndkManager
    @EnvironmentObject var themeManager: ThemeManager
    @Environment(RelayManager.self) var relayManager
    @State private var showingAbout = false
    @State private var showingProfile = false
    var body: some View {
        NavigationStack {
            List {
                // Account Section
                Section {
                    // Profile Button
                    Button(action: { showingProfile = true }) {
                        HStack {
                            Image(systemName: "person.circle.fill")
                                .font(.title)
                                .foregroundColor(.accentColor)
                            VStack(alignment: .leading) {
                                Text("My Profile")
                                    .font(.headline)
                                    .foregroundColor(.primary)
                                if let session = authManager.activeSession {
                                    Text(String(session.pubkey.prefix(8)) + "...")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                            Spacer()
                            Image(systemName: "chevron.right")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.vertical, 4)
                    }
                    NavigationLink(destination: AccountSettingsView()) {
                        HStack {
                            Image(systemName: "person.crop.circle.fill")
                                .font(.title2)
                                .foregroundColor(.blue)
                            VStack(alignment: .leading) {
                                Text("Accounts")
                                    .font(.headline)
                                if authManager.availableSessions.count > 1 {
                                    Text("\(authManager.availableSessions.count) accounts")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                // Relay Section
                Section {
                    NavigationLink(destination: RelaySettingsView()) {
                        HStack {
                            Image(systemName: "network")
                                .font(.title2)
                                .foregroundColor(.green)
                            VStack(alignment: .leading) {
                                Text("Relays")
                                    .font(.headline)
                                if let ndk = ndkManager.ndk {
                                    RelayCountView(ndk: ndk)
                                } else {
                                    Text("Not connected")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                // Appearance Section
                Section {
                    NavigationLink(destination: AppearanceSettingsView(themeManager: themeManager)) {
                        HStack {
                            Image(systemName: "paintbrush.fill")
                                .font(.title2)
                                .foregroundColor(.purple)
                            VStack(alignment: .leading) {
                                Text("Appearance")
                                    .font(.headline)
                                Text(themeManager.currentTheme.rawValue)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                // Privacy & Security Section
                Section {
                    NavigationLink(destination: PrivacySettingsView()) {
                        HStack {
                            Image(systemName: "lock.fill")
                                .font(.title2)
                                .foregroundColor(.orange)
                            Text("Privacy & Security")
                                .font(.headline)
                        }
                        .padding(.vertical, 4)
                    }
                    NavigationLink(destination: NotificationSettingsView()) {
                        HStack {
                            Image(systemName: "bell.fill")
                                .font(.title2)
                                .foregroundColor(.red)
                            Text("Notifications")
                                .font(.headline)
                        }
                        .padding(.vertical, 4)
                    }
                }
                // Advanced Section
                Section {
                    NavigationLink(destination: AdvancedSettingsView()) {
                        HStack {
                            Image(systemName: "gearshape.2.fill")
                                .font(.title2)
                                .foregroundColor(.gray)
                            Text("Advanced")
                                .font(.headline)
                        }
                        .padding(.vertical, 4)
                    }
                }
                // About Section
                Section {
                    Button(action: { showingAbout = true }) {
                        HStack {
                            Image(systemName: "info.circle.fill")
                                .font(.title2)
                                .foregroundColor(.blue)
                            VStack(alignment: .leading) {
                                Text("About Posta")
                                    .font(.headline)
                                Text("Version 1.0.0")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        .padding(.vertical, 4)
                    }
                    .foregroundColor(.primary)
                }
            }
            .navigationTitle("Settings")
            .sheet(isPresented: $showingAbout) {
                AboutView()
            }
            .sheet(isPresented: $showingProfile) {
                ProfileView(pubkey: nil)
                    .environment(authManager)
                    .environment(NDKManager.shared)
            }
        }
        .preferredColorScheme(themeManager.currentTheme.colorScheme)
        .onAppear {
            // NDK is now managed centrally
        }
    }
}
// Helper view to show relay connection count
struct RelayCountView: View {
    let ndk: NDK
    @StateObject private var relayCollection: NDKRelayCollection
    init(ndk: NDK) {
        self.ndk = ndk
        self._relayCollection = StateObject(wrappedValue: ndk.createRelayCollection())
    }
    var body: some View {
        Text("\(relayCollection.connectedCount) connected")
            .font(.caption)
            .foregroundColor(.secondary)
    }
}
</file>

<file path="Sources/Posta/SplashView.swift">
import SwiftUI
struct SplashView: View {
    @State private var isAnimating = false
    @State private var showContent = false
    @State private var logoScale: CGFloat = 0
    @State private var logoOpacity: Double = 0
    @State private var logoRotation: Double = -180
    @State private var titleOpacity: Double = 0
    @State private var glowOpacity: Double = 0
    @State private var pulseScale: CGFloat = 1
    @State private var electricityPhase: CGFloat = 0
    @Binding var isShowingSplash: Bool
    var body: some View {
        ZStack {
            // Modern animated background
            PostaBackgroundView()
            // Electric field effects
            ElectricFieldView()
                .opacity(glowOpacity * 0.3)
            VStack(spacing: 40) {
                Spacer()
                // Logo with advanced effects
                ZStack {
                    // Outer glow
                    Circle()
                        .fill(
                            RadialGradient(
                                gradient: Gradient(colors: [
                                    PostaColors.electricPurple.opacity(0.8),
                                    PostaColors.glowPink.opacity(0.4),
                                    Color.clear
                                ]),
                                center: .center,
                                startRadius: 30,
                                endRadius: 150
                            )
                        )
                        .frame(width: 350, height: 350)
                        .blur(radius: 40)
                        .scaleEffect(pulseScale)
                        .opacity(logoOpacity * 0.6)
                    // Logo container
                    ZStack {
                        // Background circle
                        Circle()
                            .fill(
                                LinearGradient(
                                    gradient: PostaColors.primaryGradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 180, height: 180)
                            .shadow(color: PostaColors.electricPurple.opacity(0.6), radius: 30, x: 0, y: 10)
                        // Logo
                        PostaLogoView(size: 110, color: .white)
                    }
                    .scaleEffect(logoScale)
                    .opacity(logoOpacity)
                    .rotationEffect(.degrees(logoRotation))
                }
                // App name with advanced styling
                VStack(spacing: 16) {
                    Text("POSTA")
                        .font(.system(size: 64, weight: .black, design: .default))
                        .tracking(6)
                        .foregroundStyle(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.white,
                                    Color.white.opacity(0.95)
                                ]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .shadow(color: PostaColors.electricPurple.opacity(0.5), radius: 20, x: 0, y: 4)
                        .opacity(titleOpacity)
                        .postaShimmer()
                    Text("ENCRYPTED NOSTR MESSAGING")
                        .font(.system(size: 14, weight: .semibold, design: .monospaced))
                        .tracking(3)
                        .foregroundColor(PostaColors.textSecondary)
                        .opacity(titleOpacity)
                }
                Spacer()
                // Modern loading indicator
                HStack(spacing: 12) {
                    ForEach(0..<3) { index in
                        Circle()
                            .fill(
                                LinearGradient(
                                    gradient: PostaColors.primaryGradient,
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .frame(width: 12, height: 12)
                            .scaleEffect(showContent ? 1 : 0.3)
                            .opacity(showContent ? 1 : 0)
                            .animation(
                                .spring(response: 0.5, dampingFraction: 0.6)
                                .delay(Double(index) * 0.1),
                                value: showContent
                            )
                    }
                }
                .padding(.bottom, 20)
                Text("Loading...")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(PostaColors.textSecondary)
                    .opacity(showContent ? 1 : 0)
                Spacer()
                    .frame(height: 80)
            }
        }
        .ignoresSafeArea()
        .onAppear {
            startAnimation()
        }
    }
    private func startAnimation() {
        // Logo entrance animation with rotation
        withAnimation(.spring(response: 1.2, dampingFraction: 0.7)) {
            logoScale = 1
            logoOpacity = 1
            logoRotation = 0
        }
        // Glow effects
        withAnimation(.easeInOut(duration: 1.5).delay(0.2)) {
            glowOpacity = 1
        }
        // Pulse animation
        withAnimation(.easeInOut(duration: 2).delay(0.8).repeatForever(autoreverses: true)) {
            pulseScale = 1.2
        }
        // Title and content fade in
        withAnimation(.easeOut(duration: 0.8).delay(0.6)) {
            titleOpacity = 1
        }
        withAnimation(.easeOut(duration: 0.6).delay(1)) {
            showContent = true
        }
        // Trigger app transition
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            withAnimation(.easeInOut(duration: 0.6)) {
                isShowingSplash = false
            }
        }
    }
}
#Preview {
    SplashView(isShowingSplash: .constant(true))
}
</file>

<file path="Sources/Posta/ThemeManager.swift">
import SwiftUI
@MainActor
class ThemeManager: ObservableObject {
    enum Theme: String, CaseIterable {
        case system = "System"
        case light = "Light"
        case dark = "Dark"
        var colorScheme: ColorScheme? {
            switch self {
            case .system:
                return nil
            case .light:
                return .light
            case .dark:
                return .dark
            }
        }
    }
    @Published var currentTheme: Theme = .system {
        didSet {
            UserDefaults.standard.set(currentTheme.rawValue, forKey: "app_theme")
        }
    }
    init() {
        if let savedTheme = UserDefaults.standard.string(forKey: "app_theme"),
           let theme = Theme(rawValue: savedTheme) {
            self.currentTheme = theme
        }
    }
}
</file>

<file path="Sources/Posta/ThreadView.swift">
import SwiftUI
import NDKSwift
struct ThreadView: View {
    let rootEvent: NDKEvent
    @Environment(NDKManager.self) var ndkManager
    @Environment(NDKAuthManager.self) var authManager
    @Environment(\.dismiss) var dismiss
    @State private var replies: [NDKEvent] = []
    @State private var replyingTo: NDKEvent?
    @State private var replyText: String = ""
    @State private var isLoadingReplies = true
    @State private var threadDataSource: NDKDataSource<NDKEvent>?
    @State private var subscriptionTask: Task<Void, Never>?
    @State private var selectedProfile: String?
    @State private var subThreads: [String: [NDKEvent]] = [:] // eventId -> replies
    @State private var showContent = false
    @State private var keyboardHeight: CGFloat = 0
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated gradient background
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(.systemBackground),
                        Color.purple.opacity(0.02),
                        Color(.systemBackground)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Thread content
                    ScrollViewReader { proxy in
                        ScrollView {
                            VStack(spacing: 0) {
                                // Root event with animation
                                ThreadEventView(
                                    event: rootEvent,
                                    isRoot: true,
                                    onAvatarTap: {
                                        selectedProfile = rootEvent.pubkey
                                    }
                                )
                                .id("root")
                                .opacity(showContent ? 1 : 0)
                                .scaleEffect(showContent ? 1 : 0.95)
                                .animation(.spring(response: 0.5, dampingFraction: 0.8), value: showContent)
                                Divider()
                                    .padding(.leading, 20)
                                // Replies with staggered animation
                                ForEach(Array(replies.sorted(by: { $0.createdAt < $1.createdAt }).enumerated()), id: \.element.id) { index, reply in
                                    ThreadReplyView(
                                        event: reply,
                                        isReplyingTo: replyingTo?.id == reply.id,
                                        subReplies: subThreads[reply.id] ?? [],
                                        onTap: {
                                            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                                replyingTo = replyingTo?.id == reply.id ? nil : reply
                                                HapticFeedback.selection()
                                            }
                                        },
                                        onAvatarTap: {
                                            selectedProfile = reply.pubkey
                                        },
                                        onSubThreadTap: {
                                            HapticFeedback.impact(.light)
                                            // TODO: Navigate to sub-thread view
                                        }
                                    )
                                    .id(reply.id)
                                    .opacity(showContent ? 1 : 0)
                                    .offset(y: showContent ? 0 : 20)
                                    .animation(.spring(response: 0.5, dampingFraction: 0.8).delay(Double(index) * 0.05), value: showContent)
                                    if reply.id != replies.last?.id {
                                        Divider()
                                            .padding(.leading, 72)
                                    }
                                }
                                // Loading indicator
                                if isLoadingReplies {
                                    LoadingDots(dotSize: 10, color: .purple)
                                        .padding()
                                }
                            }
                        }
                    }
                    // Reply composition
                    replyComposer
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .principal) {
                    HStack(spacing: 6) {
                        Image(systemName: "bubble.left.and.bubble.right")
                            .font(.system(size: 16))
                            .foregroundColor(.purple)
                        Text("Thread")
                            .font(.headline)
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        HapticFeedback.impact(.light)
                        dismiss()
                    }) {
                        Text("Done")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(.purple)
                    }
                }
            }
        }
        .sheet(item: $selectedProfile) { pubkey in
            ProfileView(pubkey: pubkey)
        }
        .onAppear {
            loadThread()
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8).delay(0.1)) {
                showContent = true
            }
        }
        .onDisappear {
            subscriptionTask?.cancel()
        }
    }
    private var replyComposer: some View {
        VStack(spacing: 0) {
            // Reply target indicator with animation
            if let target = replyingTo {
                HStack {
                    ProfileLoader(pubkey: target.pubkey) { profile in
                        HStack(spacing: 4) {
                            Image(systemName: "arrow.turn.up.right")
                                .font(.system(size: 12))
                                .foregroundColor(.purple)
                            Text("Replying to \(profile?.displayName ?? "Unknown")")
                                .font(.system(size: 14, weight: .medium))
                                .foregroundColor(.primary)
                        }
                    }
                    Spacer()
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            replyingTo = nil
                            HapticFeedback.impact(.light)
                        }
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                            .font(.system(size: 16))
                    }
                }
                .padding(.horizontal)
                .padding(.vertical, 10)
                .background(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.purple.opacity(0.1),
                            Color.purple.opacity(0.05)
                        ]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .transition(.asymmetric(
                    insertion: .push(from: .top).combined(with: .opacity),
                    removal: .push(from: .bottom).combined(with: .opacity)
                ))
            }
            // Reply input with modern styling
            HStack(spacing: 12) {
                TextField("Reply to thread...", text: $replyText, axis: .vertical)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 10)
                    .background(
                        RoundedRectangle(cornerRadius: 20)
                            .fill(Color(.systemGray6))
                    )
                    .lineLimit(1...5)
                Button(action: {
                    sendReply()
                    HapticFeedback.notification(.success)
                }) {
                    ZStack {
                        Circle()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: replyText.isEmpty ? 
                                        [Color(.systemGray5), Color(.systemGray5)] :
                                        [Color.purple, Color.purple.opacity(0.8)]
                                    ),
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 36, height: 36)
                        Image(systemName: "paperplane.fill")
                            .font(.system(size: 16))
                            .foregroundColor(.white)
                            .rotationEffect(.degrees(45))
                    }
                }
                .disabled(replyText.isEmpty)
                .scaleEffect(replyText.isEmpty ? 1 : 1.1)
                .animation(.spring(response: 0.3, dampingFraction: 0.7), value: replyText.isEmpty)
            }
            .padding()
            .background(
                VisualEffectBlur(blurStyle: .systemUltraThinMaterial)
                    .ignoresSafeArea()
            )
        }
    }
    private func loadThread() {
        guard let ndk = ndkManager.ndk else { return }
        // Subscribe to replies
        subscriptionTask = Task {
            let replyFilter = NDKFilter(
                kinds: [EventKind.textNote],
                tags: ["e": Set([rootEvent.id])]
            )
            threadDataSource = ndk.observe(filter: replyFilter)
            guard let dataSource = threadDataSource else { return }
            for await reply in dataSource.events {
                await MainActor.run {
                    // Add reply if it's new
                    if !replies.contains(where: { $0.id == reply.id }) {
                        replies.append(reply)
                        // Check for sub-replies (replies to this reply)
                        loadSubReplies(for: reply.id)
                    }
                }
            }
            await MainActor.run {
                isLoadingReplies = false
            }
        }
    }
    private func loadSubReplies(for eventId: String) {
        guard let ndk = ndkManager.ndk else { return }
        Task {
            let subReplyFilter = NDKFilter(
                kinds: [EventKind.textNote],
                tags: ["e": Set([eventId])]
            )
            // Use observe with maxAge > 0 to fetch and close after EOSE
            let dataSource = ndk.observe(filter: subReplyFilter, maxAge: 60)
            var events: [NDKEvent] = []
            for await event in dataSource.events {
                events.append(event)
            }
            await MainActor.run {
                var subReplies: [NDKEvent] = []
                for event in events {
                    // Check if this is a direct reply to the target event
                    let eTags = event.tags.filter { $0.count >= 2 && $0[0] == "e" }
                    if let lastETag = eTags.last, lastETag[1] == eventId {
                        subReplies.append(event)
                    }
                }
                if !subReplies.isEmpty {
                    self.subThreads[eventId] = subReplies
                }
            }
        }
    }
    private func sendReply() {
        guard let ndk = ndkManager.ndk,
              let signer = authManager.activeSigner,
              !replyText.isEmpty else { return }
        Task {
            do {
                let targetEvent = replyingTo ?? rootEvent
                // Build NIP-10 compliant tags
                var tags: [Tag] = []
                // Add root tag if we're replying to a reply
                if targetEvent.id != rootEvent.id {
                    tags.append(["e", rootEvent.id, "", "root"])
                }
                // Add reply tag
                tags.append(["e", targetEvent.id, "", "reply"])
                // Add p tags for mentioned users
                tags.append(["p", targetEvent.pubkey])
                if targetEvent.id != rootEvent.id {
                    tags.append(["p", rootEvent.pubkey])
                }
                let replyEvent = try await NDKEventBuilder(ndk: ndk)
                    .kind(EventKind.textNote)
                    .content(replyText)
                    .tags(tags)
                    .build(signer: signer)
                try await ndk.publish(replyEvent)
                await MainActor.run {
                    replyText = ""
                    replyingTo = nil
                }
            } catch {
                print("Failed to send reply: \(error)")
            }
        }
    }
}
struct ThreadEventView: View {
    let event: NDKEvent
    let isRoot: Bool
    let onAvatarTap: () -> Void
    @Environment(NDKManager.self) var ndkManager
    var body: some View {
        ProfileLoader(pubkey: event.pubkey) { profile in
            VStack(alignment: .leading, spacing: 12) {
                // Author info
                HStack(alignment: .top, spacing: 12) {
                    // Avatar with enhanced styling
                    Button(action: {
                        onAvatarTap()
                        HapticFeedback.impact(.light)
                    }) {
                        EnhancedAvatarView(
                            url: profile?.picture.flatMap { URL(string: $0) },
                            size: 52,
                            fallbackText: String(profile?.name?.prefix(1) ?? "?").uppercased(),
                            showOnlineIndicator: false
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    // Name and time
                    VStack(alignment: .leading, spacing: 2) {
                        Text(profile?.displayName ?? profile?.name ?? "Unknown")
                            .font(.system(size: 16, weight: .semibold))
                        Text(event.createdAt.formatted)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    Spacer()
                }
                // Content with enhanced typography
                RichTextView(
                    content: event.content,
                    tags: event.tags,
                    currentUser: nil
                )
                .font(.system(size: isRoot ? 16 : 15))
                .textSelection(.enabled)
                // Engagement stats for root event
                if isRoot {
                    HStack(spacing: 20) {
                        HStack(spacing: 4) {
                            Image(systemName: "bubble.left")
                                .font(.system(size: 14))
                            Text("0")
                                .font(.system(size: 14))
                        }
                        .foregroundColor(.secondary)
                        HStack(spacing: 4) {
                            Image(systemName: "arrow.2.squarepath")
                                .font(.system(size: 14))
                            Text("0")
                                .font(.system(size: 14))
                        }
                        .foregroundColor(.secondary)
                        HStack(spacing: 4) {
                            Image(systemName: "heart")
                                .font(.system(size: 14))
                            Text("0")
                                .font(.system(size: 14))
                        }
                        .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.top, 8)
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: isRoot ? 16 : 0)
                    .fill(isRoot ? 
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.purple.opacity(0.05),
                                Color.purple.opacity(0.02)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ) : 
                        LinearGradient(
                            gradient: Gradient(colors: [Color.clear, Color.clear]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
            )
            .padding(.horizontal, isRoot ? 12 : 0)
        }
    }
}
struct ThreadReplyView: View {
    let event: NDKEvent
    let isReplyingTo: Bool
    let subReplies: [NDKEvent]
    let onTap: () -> Void
    let onAvatarTap: () -> Void
    let onSubThreadTap: () -> Void
    @Environment(NDKManager.self) var ndkManager
    @State private var isPressed = false
    var body: some View {
        ProfileLoader(pubkey: event.pubkey) { profile in
            VStack(alignment: .leading, spacing: 0) {
                HStack(alignment: .top, spacing: 12) {
                    // Thread line and avatar
                    VStack(spacing: 4) {
                        Button(action: {
                            onAvatarTap()
                            HapticFeedback.impact(.light)
                        }) {
                            EnhancedAvatarView(
                                url: profile?.picture.flatMap { URL(string: $0) },
                                size: 40,
                                fallbackText: String(profile?.name?.prefix(1) ?? "?").uppercased(),
                                showOnlineIndicator: false
                            )
                        }
                        .buttonStyle(PlainButtonStyle())
                        // Thread line
                        if !subReplies.isEmpty {
                            Rectangle()
                                .fill(Color.purple.opacity(0.2))
                                .frame(width: 2)
                                .frame(maxHeight: .infinity)
                        }
                    }
                    .padding(.leading, 20)
                    // Content
                    VStack(alignment: .leading, spacing: 6) {
                        HStack {
                            Text(profile?.displayName ?? profile?.name ?? "Unknown")
                                .font(.system(size: 15, weight: .medium))
                            Text("")
                                .foregroundColor(.secondary)
                            Text(event.createdAt.formatted)
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Spacer()
                        }
                        RichTextView(
                            content: event.content,
                            tags: event.tags,
                            currentUser: nil
                        )
                        .font(.system(size: 15))
                        .foregroundColor(.primary.opacity(0.9))
                        // Sub-thread indicator
                        if !subReplies.isEmpty {
                            SubThreadIndicator(
                                subReplies: subReplies,
                                onTap: onSubThreadTap
                            )
                            .padding(.top, 8)
                        }
                    }
                    .padding(.trailing, 20)
                }
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(isReplyingTo ? 
                            Color.purple.opacity(0.1) : 
                            (isPressed ? Color.purple.opacity(0.05) : Color.clear)
                        )
                        .padding(.horizontal, 12)
                )
                .contentShape(Rectangle())
                .scaleEffect(isPressed ? 0.98 : 1)
                .onLongPressGesture(
                    minimumDuration: 0,
                    maximumDistance: .infinity,
                    pressing: { pressing in
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            isPressed = pressing
                        }
                    },
                    perform: onTap
                )
            }
        }
    }
}
// Simplified sub-thread indicator view
struct SubThreadIndicator: View {
    let subReplies: [NDKEvent]
    let onTap: () -> Void
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 8) {
                // Avatar stack - show first 3 unique reply authors
                HStack(spacing: -6) {
                    ForEach(Array(Set(subReplies.prefix(3).map { $0.pubkey })).prefix(3), id: \.self) { pubkey in
                        MiniAvatar(pubkey: pubkey)
                    }
                }
                Text("\(subReplies.count) \(subReplies.count == 1 ? "reply" : "replies")")
                    .font(.caption)
                    .foregroundColor(.accentColor)
                Spacer()
            }
        }
    }
}
// Mini avatar for sub-thread indicator
struct MiniAvatar: View {
    let pubkey: String
    @Environment(NDKManager.self) var ndkManager
    @State private var profile: NDKUserProfile?
    @State private var profileTask: Task<Void, Never>?
    var body: some View {
        Group {
            if let avatarURL = profile?.picture, let url = URL(string: avatarURL) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle()
                        .fill(Color(.tertiarySystemFill))
                }
                .frame(width: 20, height: 20)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(Color(.systemBackground), lineWidth: 1.5)
                )
            } else {
                Circle()
                    .fill(Color(.tertiarySystemFill))
                    .frame(width: 20, height: 20)
                    .overlay(
                        Circle()
                            .stroke(Color(.systemBackground), lineWidth: 1.5)
                    )
            }
        }
        .onAppear {
            loadProfile()
        }
        .onDisappear {
            profileTask?.cancel()
        }
    }
    private func loadProfile() {
        guard let ndk = ndkManager.ndk else { return }
        profileTask = Task {
            let profileStream = await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour)
            for await profile in profileStream {
                if let profile = profile {
                    await MainActor.run {
                        self.profile = profile
                    }
                    break
                }
            }
        }
    }
}
</file>

<file path="Sources/Posta/VisualEffectBlur.swift">
import SwiftUI
struct VisualEffectBlur: UIViewRepresentable {
    var blurStyle: UIBlurEffect.Style
    func makeUIView(context: Context) -> UIVisualEffectView {
        UIVisualEffectView(effect: UIBlurEffect(style: blurStyle))
    }
    func updateUIView(_ uiView: UIVisualEffectView, context: Context) {
        uiView.effect = UIBlurEffect(style: blurStyle)
    }
}
</file>

<file path="build.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
# Get app name from directory
APP_NAME=$(basename "$SCRIPT_DIR")
echo -e "${YELLOW} Regenerating Xcode project...${NC}"
# Check if xcodegen is installed
if ! command -v xcodegen &> /dev/null; then
    echo -e "${RED} xcodegen is not installed. Installing via Homebrew...${NC}"
    brew install xcodegen
fi
# Generate Xcode project
xcodegen generate
echo -e "${GREEN} Xcode project regenerated${NC}"
# Build the project
echo -e "${YELLOW}  Building ${APP_NAME}...${NC}"
# Set default values
DESTINATION="${DESTINATION:-platform=iOS Simulator,name=iPhone 15 Pro}"
CONFIGURATION="${CONFIGURATION:-Debug}"
SCHEME="${SCHEME:-$APP_NAME}"
# Build with xcbeautify for cleaner output
set -o pipefail && xcodebuild \
    -project "${APP_NAME}.xcodeproj" \
    -scheme "$SCHEME" \
    -destination "$DESTINATION" \
    -configuration "$CONFIGURATION" \
    build \
    | xcbeautify
echo -e "${GREEN} Build completed successfully${NC}"
</file>

<file path="deploy.sh">
#!/bin/bash
cd "$(dirname "$0")/.."
./deploy-testflight.sh Posta
</file>

<file path="project.yml">
name: Posta
options:
  bundleIdPrefix: com.posta
  deploymentTarget:
    iOS: "17.0"
settings:
  base:
    # Code Signing Settings - Update these with your values
    DEVELOPMENT_TEAM: "456SHKPP26"
    CODE_SIGN_STYLE: Automatic
    CODE_SIGN_IDENTITY: "Apple Development"
    PROVISIONING_PROFILE_SPECIFIER: ""
    # App Settings
    PRODUCT_BUNDLE_IDENTIFIER: com.posta.app
    MARKETING_VERSION: "1.0.0"
    CURRENT_PROJECT_VERSION: "1"
packages:
  NDKSwift:
    path: ../../..
targets:
  Posta:
    type: application
    platform: iOS
    sources: 
      - Sources/Posta
    dependencies:
      - package: NDKSwift
        product: NDKSwift
      - package: NDKSwift
        product: NDKSwiftUI
    info:
      path: Sources/Posta/Info.plist
      properties:
        UILaunchStoryboardName: LaunchScreen
        LSRequiresIPhoneOS: true
        UIApplicationSceneManifest:
          UIApplicationSupportsMultipleScenes: false
        UIRequiredDeviceCapabilities:
          - arm64
    settings:
      base:
        INFOPLIST_FILE: Sources/Posta/Info.plist
        PRODUCT_NAME: Posta
        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
        TARGETED_DEVICE_FAMILY: "1,2"
        SUPPORTS_MACCATALYST: false
        SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD: false
</file>

<file path="README.md">
# Posta - A Telegram-like iOS App

Posta is a basic iOS app that demonstrates how to build a Telegram-like interface using NDKSwift for Nostr protocol integration.

## Features

- **Authentication System**: Login with existing private key or register a new account
- **Clean SwiftUI Interface**: Modern iOS app design with tab navigation
- **NDKSwift Integration**: Ready for Nostr protocol communication
- **Home Screen Shell**: Prepared for kind:1 note fetching and display

## Architecture

The app follows clean architecture principles:

- `PostaApp.swift` - Main app entry point
- `AuthManager.swift` - Handles authentication and NDK instance management
- `AuthView.swift` - Login/Register interface
- `ContentView.swift` - Main app coordinator
- `HomeView.swift` - Home screen (ready for posts implementation)

## Building

1. Make sure you have Xcode installed
2. Generate the Xcode project:
   ```bash
   cd Examples/Posta
   xcodegen
   ```
3. Open `Posta.xcodeproj` in Xcode
4. Build and run on iOS Simulator

## Next Steps

The home screen is intentionally left empty. You can extend it to:

1. Fetch kind:1 notes from Nostr relays
2. Filter out notes with "e" tags (to show only root posts)
3. Display author avatars and message previews
4. Implement Telegram-like chat interface

## Dependencies

- **NDKSwift**: Nostr Development Kit for Swift
- **iOS 17.0+**: Minimum deployment target
- **SwiftUI**: Modern UI framework
</file>

<file path="refresh-project.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW} Refreshing Xcode project after file changes...${NC}"
# Clean derived data if requested
if [[ "${CLEAN:-false}" == "true" ]]; then
    echo -e "${YELLOW} Cleaning derived data...${NC}"
    rm -rf .build/DerivedData
fi
# Regenerate project
xcodegen generate --spec project.yml
echo -e "${GREEN} Project refreshed! The .xcodeproj now includes all current files.${NC}"
echo -e "${GREEN}   Code signing is configured from project.yml${NC}"
</file>

</files>
